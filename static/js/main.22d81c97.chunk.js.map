{"version":3,"sources":["components/BurgerButton.tsx","img/github.svg","img/telegram.svg","img/twitter.svg","img/discord.svg","components/Header.tsx","components/Footer.tsx","routes/Collections.tsx","components/MintButton.tsx","img/box.svg","components/MintComponent.tsx","routes/HomePage.tsx","components/Overlay.tsx","App.tsx","hooks/useOnClickOutside.ts","reportWebVitals.ts","index.tsx","scripts/utils.ts","scripts/connection.tsx","scripts/candy-machine.ts"],"names":["Burger","props","className","onClick","setOpen","open","style","transform","width","opacity","Header","useWallet","backgroundColor","href","staking","nft","src","github","alt","telegram","twitter","discord","Footer","Collections","useState","coll","result","data","collections","map","collection","to","name","items","MintButton","onMint","candyMachine","isMinting","setIsMinting","isActive","wallet","connection","useConnection","verified","setVerified","useGateway","requestGatewayToken","gatewayStatus","webSocketSubscriptionId","setWebSocketSubscriptionId","clicked","setClicked","useEffect","mint","a","removeAccountChangeListener","previousGatewayStatus","value","ref","useRef","current","usePrevious","fromStates","GatewayStatus","NOT_REQUESTED","REFRESH_TOKEN_REQUIRED","invalidToStates","UNKNOWN","find","state","console","log","disabled","gatekeeper","network","gatekeeperNetwork","toBase58","ACTIVE","findGatewayToken","publicKey","gatewayToken","isValid","window","getGatewayTokenAddressForOwnerAndGatekeeperNetwork","gatewayTokenAddress","onGatewayTokenChange","Error","isSoldOut","isPresale","isWhitelistOnly","formatNumber","asNumber","price","MintComponent","message","severity","undefined","setAlertState","setCandyMachine","setDiscountPrice","setEndDate","isUserMinting","setIsUserMinting","setIsActive","itemsRemaining","setItemsRemaining","isWhitelistUser","setIsWhitelistUser","setIsPresale","rpcUrl","rpcHost","anchorWallet","useMemo","signAllTransactions","signTransaction","refreshCandyMachineState","useCallback","candyMachineId","getCandyMachineState","cndy","active","goLiveDate","toNumber","Date","getTime","presale","whitelistMintSettings","discountPrice","anchor","PublicKey","getAtaForMint","token","getTokenAccountBalance","balance","valid","parseInt","amount","endSettings","endSettingType","date","toDate","number","limit","Math","min","itemsAvailable","itemsRedeemed","beforeTransactions","afterTransactions","document","getElementById","click","connected","program","mintOneToken","mintOne","mintTxId","status","err","awaitTransactionSignatureConfirmation","txTimeout","remaining","msg","code","location","reload","indexOf","CANDY_MACHINE_PROGRAM","clusterUrl","handleTransaction","transaction","signatures","sig","equals","sendTransaction","error","broadcastTransaction","options","autoShowModal","val","box","HomePage","Overlay","require","process","e","getCandyMachineId","Connection","App","handler","node","listener","event","contains","target","addEventListener","removeEventListener","endpoint","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSlopeWallet","getSolletWallet","getSolletExtensionWallet","ConnectionProvider","WalletProvider","autoConnect","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","numberFormater","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","format","LAMPORTS_PER_SOL","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","CIVIC","buyer","findProgramAddress","toBuffer","TOKEN_PROGRAM_ID","getNetworkExpire","Buffer","from","getNetworkToken","SequenceType","getErrorForTransaction","txid","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","forEach","m","regex","exec","index","lastIndex","length","push","sendTransactions","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","i","instructions","signers","Transaction","instruction","add","recentBlockhash","blockhash","setSigners","s","partialSign","partiallySignedTransactions","filter","t","fullySignedTransactions","signedTxns","concat","pendingTxns","signedTxnPromise","sendSignedTransaction","signedTransaction","slot","StopOnFailure","Promise","all","txs","awaitConfirmation","includesFeePayer","rawTransaction","serialize","skipPreflight","sendRawTransaction","DEFAULT_TIMEOUT","confirmation","getUnixTs","timeout","startTime","done","sleep","simulateResult","simulateTransaction","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","queryStatus","confirmations","subId","resolve","reject","setTimeout","onSignature","context","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms","TOKEN_METADATA_PROGRAM_ID","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","SystemProgram","programId","SYSVAR_RENT_PUBKEY","TransactionInstruction","provider","preflightCommitment","fetchIdl","idl","account","fetch","id","authority","treasury","tokenMint","hiddenSettings","retainAuthority","getMasterEdition","getMetadata","getCandyMachineCreator","getCollectionPDA","candyMachineAddress","getCollectionAuthorityRecordPDA","newAuthority","Keypair","generate","userTokenAccountAddress","userPayingAccountAddress","remainingAccounts","cleanupInstructions","MintLayout","span","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","lamports","createAccount","Token","createInitMintInstruction","createMintToInstruction","expireOnUse","whitelistToken","mode","burnEveryTime","whitelistBurnAuthority","getAccountInfo","createApproveInstruction","createRevokeInstruction","transferAuthority","metadataAddress","masterEdition","candyMachineCreator","creatorBump","rm","mintNft","accounts","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_SLOT_HASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","collectionPDA","collectionPDAAccount","collectionPda","collectionData","collectionMint","collectionAuthorityRecord","collectionMetadata","collectionMasterEdition","setCollectionDuringMint","instructionsMatrix","signersMatrix","txnEstimate","INIT_INSTRUCTIONS_LENGTH","INIT_SIGNERS_LENGTH","initInstructions","splice","initSigners"],"mappings":"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","file":"static/js/main.22d81c97.chunk.js","sourcesContent":["export default function Burger (props:any) {\r\n    return (\r\n        <button className=\"burger\" onClick={() => props.setOpen(!props.open)}>\r\n            <div style={{transform:  props.open ? 'rotate(45deg)' : 'translateY(-6px)', width : \"28px\"}}></div>\r\n            <div style={{transform:  props.open ? 'translateX(20px)' : 'scaleX(1)', opacity: props.open ? '0' : '1', width : \"20px\"}}></div>\r\n            <div style={{transform:  props.open ? 'rotate(-45deg)' : 'translateY(6px)', width : \"28px\"}}></div>\r\n        </button>\r\n    )\r\n};\r\n","export default __webpack_public_path__ + \"static/media/github.6cd3efeb.svg\";","export default __webpack_public_path__ + \"static/media/telegram.c2ac02ad.svg\";","export default __webpack_public_path__ + \"static/media/twitter.deedb5ed.svg\";","export default __webpack_public_path__ + \"static/media/discord.2fd207e1.svg\";","import \"../styles/HeaderFooter.css\";\r\nimport Burger from \"./BurgerButton\";\r\nimport github from \"../img/github.svg\";\r\nimport telegram from \"../img/telegram.svg\";\r\nimport twitter from \"../img/twitter.svg\";\r\nimport discord from \"../img/discord.svg\";\r\nimport { useWallet } from '@solana/wallet-adapter-react';\r\nimport { WalletMultiButton } from '@solana/wallet-adapter-react-ui';\r\n\r\n\r\nexport default function Header (props:any) {\r\n    const wallet = useWallet();\r\n\r\n    return (\r\n        <div className=\"header\" style={{backgroundColor: props.open && \"#191919\"  }}>\r\n            <a href=\"|\" className=\"header-logo\">\r\n            </a>\r\n            <nav className=\"header-menu\">\r\n                <ul className=\"header-menu-ul\">\r\n                    <li className=\"header-menu-li\" onClick={props.staking}>Staking</li>\r\n                    <li className=\"header-menu-li\"> <a href=\"https://sibe-finance.github.io/sibe-docs/\">Docs</a></li>\r\n                    <li className=\"header-menu-li\">Sibe paper</li>\r\n                    <li className=\"header-menu-li\" onClick={props.nft}>Sibe NFT</li>\r\n                    <li className=\"header-menu-li\">Roadmap</li>\r\n                </ul>\r\n            </nav>\r\n            <nav className=\"header-socials\">\r\n                <ul className=\"header-socials-ul\">\r\n                    <li className=\"header-socials-li\"><a href=\"github\"><img src={github} alt=\"https://github.com/sibe-finance\" /></a></li>\r\n                    <li className=\"header-socials-li\"><a href=\"telegram\"><img src={telegram} alt=\"https://t.me/SIBEprotocol\" /></a></li>\r\n                    <li className=\"header-socials-li\"><a href=\"twitter\"><img src={twitter} alt=\"https://twitter.com/SibeGameFi?t=P1crNdFCL3F3p71_31zpLA&s=09\" /></a></li>\r\n                    <li className=\"header-socials-li\"><a href=\"discord\"><img src={discord} alt=\"https://discord.com/invite/yE3Q6mG9De\" /></a></li>\r\n                </ul>\r\n            </nav>\r\n            <WalletMultiButton className=\"header-connect-wallet\"></WalletMultiButton>\r\n            <Burger open={props.open} setOpen={props.setOpen} />\r\n        </div>\r\n    )\r\n};","import \"../styles/HeaderFooter.css\";\r\nimport github from \"../img/github.svg\";\r\nimport telegram from \"../img/telegram.svg\";\r\nimport twitter from \"../img/twitter.svg\";\r\nimport discord from \"../img/discord.svg\";\r\n\r\n\r\nexport default function Footer () {\r\n    return <div className=\"footer\"> \r\n        <nav className=\"footer-socials\">\r\n            <ul className=\"footer-socials-ul\">\r\n                <li className=\"footer-socials-li\"><a href=\"https://github.com/sibe-finance\"><img src={github} alt=\"github\" /></a></li>\r\n                <li className=\"footer-socials-li\"><a href=\"https://t.me/SIBEprotocol\"><img src={telegram} alt=\"telegram\" /></a></li>\r\n                <li className=\"footer-socials-li\"><a href=\"https://twitter.com/SibeGameFi?t=P1crNdFCL3F3p71_31zpLA&s=09\"><img src={twitter} alt=\"twitter\" /></a></li>\r\n                <li className=\"footer-socials-li\"><a href=\"https://discord.com/invite/yE3Q6mG9De\"><img src={discord} alt=\"discord\" /></a></li>\r\n            </ul>\r\n        </nav>\r\n        <nav className=\"footer-menu\">\r\n            <ul className=\"footer-menu-ul\">\r\n            <li className=\"footer-menu-li\"><a href=\"https://github.com/sibe-finance\">Github</a></li>\r\n            <li className=\"footer-menu-li\"><a href=\"/\">Sibe NFT</a></li>\r\n            <li className=\"footer-menu-li\"><a href=\"/\">Docs</a></li>\r\n            <li className=\"footer-menu-li\"><a href=\"https://sibe-finance.github.io/sibe-docs/\">Cispracs</a></li>\r\n            <li className=\"footer-menu-li\"><a href=\"/\">Roadmap</a></li>\r\n            </ul>\r\n        </nav>\r\n    </div>\r\n}","import { useState } from 'react';\r\nimport {\r\n    Link,\r\n    Outlet\r\n  } from \"react-router-dom\";\r\nimport coll from '../collections.json';\r\n\r\nexport default function Collections(props:any) {\r\n    const [collections, setCollections] = useState(coll.result.data);\r\n    \r\n    return (\r\n        <div className=\"collections-wrapper\">\r\n        {collections?.map((collection)=> (\r\n          <Link to={`/collections/${collection.name}}`} key={collection.name} className=\"collection-item-wrapper\">\r\n            <div className=\"collection-item-logo\"></div>\r\n            <h3 className=\"collection-item-header\">{collection.name}</h3>\r\n            <div className=\"collection-item-volume volume\">\r\n                    <h4 className=\"collection-item-volume-h4 volume-h4\">Volume</h4>\r\n                    <span className=\"collection-item-volume-data volume-data\"> {collection.items} </span>\r\n                </div>\r\n          </Link>\r\n        ))}\r\n        <Outlet />\r\n      </div>\r\n    );\r\n}","import { CandyMachineAccount } from '../scripts/candy-machine';\nimport { GatewayStatus, useGateway } from '@civic/solana-gateway-react';\nimport { useEffect, useState, useRef } from 'react';\nimport { useConnection, useWallet } from '@solana/wallet-adapter-react';\nimport {\n  findGatewayToken,\n  getGatewayTokenAddressForOwnerAndGatekeeperNetwork,\n  onGatewayTokenChange,\n  removeAccountChangeListener,\n} from '@identity.com/solana-gateway-ts';\nimport { formatNumber } from '../scripts/utils';\n\n\nexport const MintButton = ({\n  onMint,\n  candyMachine,\n  isMinting,\n  setIsMinting,\n  isActive,\n}: {\n  onMint: () => Promise<void>;\n  candyMachine?: CandyMachineAccount;\n  isMinting: boolean;\n  setIsMinting: (val: boolean) => void;\n  isActive: boolean;\n}) => {\n  const wallet = useWallet();\n  const connection = useConnection();\n  const [verified, setVerified] = useState(false);\n  const { requestGatewayToken, gatewayStatus } = useGateway();\n  const [webSocketSubscriptionId, setWebSocketSubscriptionId] = useState(-1);\n  const [clicked, setClicked] = useState(false);\n\n  const getMintButtonContent = () => {\n    if (candyMachine?.state.isSoldOut) {\n      return 'SOLD OUT';\n    } else if (isMinting) {\n      return 'Loading...';\n    } else if (\n      candyMachine?.state.isPresale ||\n      candyMachine?.state.isWhitelistOnly\n    ) {\n      return 'WHITELIST MINT';\n    }\n\n    return `Buy now ${formatNumber.asNumber(candyMachine?.state.price) || 0.05} SOL`;\n  };\n\n  useEffect(() => {\n    const mint = async () => {\n      await removeAccountChangeListener(\n        connection.connection,\n        webSocketSubscriptionId,\n      );\n      await onMint();\n\n      setClicked(false);\n      setVerified(false);\n    };\n    if (verified && clicked) {\n      mint();\n    }\n  }, [\n    verified,\n    clicked,\n    connection.connection,\n    onMint,\n    webSocketSubscriptionId,\n  ]);\n\n  const previousGatewayStatus = usePrevious(gatewayStatus);\n  useEffect(() => {\n    const fromStates = [\n      GatewayStatus.NOT_REQUESTED,\n      GatewayStatus.REFRESH_TOKEN_REQUIRED,\n    ];\n    const invalidToStates = [...fromStates, GatewayStatus.UNKNOWN];\n    if (\n      fromStates.find(state => previousGatewayStatus === state) &&\n      !invalidToStates.find(state => gatewayStatus === state)\n    ) {\n      setIsMinting(true);\n    }\n    console.log('change: ', gatewayStatus);\n  }, [setIsMinting, previousGatewayStatus, gatewayStatus]);\n\n  return (\n    <button\n    className='mint-button'\n      disabled={isMinting || !isActive}\n      onClick={async () => {\n        if (candyMachine?.state.isActive && candyMachine?.state.gatekeeper) {\n          const network =\n            candyMachine.state.gatekeeper.gatekeeperNetwork.toBase58();\n          if (network === 'ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6') {\n            if (gatewayStatus === GatewayStatus.ACTIVE) {\n              await onMint();\n            } else {\n              // setIsMinting(true);\n              await requestGatewayToken();\n              console.log('after: ', gatewayStatus);\n            }\n          } else if (\n            network === 'ttib7tuX8PTWPqFsmUFQTj78MbRhUmqxidJRDv4hRRE' ||\n            network === 'tibePmPaoTgrs929rWpu755EXaxC7M3SthVCf6GzjZt'\n          ) {\n            setClicked(true);\n            const gatewayToken = await findGatewayToken(\n              connection.connection,\n              wallet.publicKey!,\n              candyMachine.state.gatekeeper.gatekeeperNetwork,\n            );\n\n            if (gatewayToken?.isValid()) {\n              await onMint();\n            } else {\n              window.open(\n                `https://verify.encore.fans/?gkNetwork=${network}`,\n                '_blank',\n              );\n\n              const gatewayTokenAddress =\n                await getGatewayTokenAddressForOwnerAndGatekeeperNetwork(\n                  wallet.publicKey!,\n                  candyMachine.state.gatekeeper.gatekeeperNetwork,\n                );\n\n              setWebSocketSubscriptionId(\n                onGatewayTokenChange(\n                  connection.connection,\n                  gatewayTokenAddress,\n                  () => setVerified(true),\n                  'confirmed',\n                ),\n              );\n            }\n          } else {\n            setClicked(false);\n            throw new Error(`Unknown Gatekeeper Network: ${network}`);\n          }\n        } else {\n          await onMint();\n          setClicked(false);\n        }\n      }}\n    >\n      {getMintButtonContent()}\n    </button>\n  );\n};\n\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n","export default __webpack_public_path__ + \"static/media/box.c530f7bb.svg\";","import * as anchor from '@project-serum/anchor';\r\nimport {\r\n    awaitTransactionSignatureConfirmation,\r\n    CandyMachineAccount,\r\n    CANDY_MACHINE_PROGRAM,\r\n    getCandyMachineState,\r\n    mintOneToken,\r\n  } from '../scripts/candy-machine';\r\nimport { AlertState, getAtaForMint, toDate } from '../scripts/utils';\r\nimport { GatewayProvider } from '@civic/solana-gateway-react';\r\nimport { useEffect, useMemo, useState, useCallback } from 'react';\r\nimport { useWallet } from '@solana/wallet-adapter-react';\r\nimport { MintButton } from '../components/MintButton';\r\nimport { PublicKey, Transaction } from '@solana/web3.js';\r\nimport { sendTransaction } from '../scripts/connection';\r\nimport box from '../img/box.svg';\r\n\r\n\r\nexport interface MintCompProps {\r\n    candyMachineId?: anchor.web3.PublicKey;\r\n    connection: anchor.web3.Connection;\r\n    txTimeout: number;\r\n    rpcHost: string;\r\n}\r\n\r\nexport default function MintComponent(props:MintCompProps) {\r\n    const [alertState, setAlertState] = useState<AlertState>({\r\n        open: false,\r\n        message: '',\r\n        severity: undefined,\r\n      });\r\n    const [candyMachine, setCandyMachine] = useState<CandyMachineAccount>();\r\n    const [discountPrice, setDiscountPrice] = useState<anchor.BN>();\r\n    const [endDate, setEndDate] = useState<Date>();\r\n    const [isUserMinting, setIsUserMinting] = useState(false);\r\n    const [isActive, setIsActive] = useState(false);\r\n    const [itemsRemaining, setItemsRemaining] = useState<number>();\r\n    const [isWhitelistUser, setIsWhitelistUser] = useState(false);\r\n    const [isPresale, setIsPresale] = useState(false);\r\n\r\n    const rpcUrl = props.rpcHost;\r\n    const wallet = useWallet();\r\n  \r\n    const anchorWallet = useMemo(() => {\r\n      if (\r\n        !wallet ||\r\n        !wallet.publicKey ||\r\n        !wallet.signAllTransactions ||\r\n        !wallet.signTransaction\r\n      ) {\r\n        return;\r\n      }\r\n  \r\n      return {\r\n        publicKey: wallet.publicKey,\r\n        signAllTransactions: wallet.signAllTransactions,\r\n        signTransaction: wallet.signTransaction,\r\n      } as anchor.Wallet;\r\n    }, [wallet]);\r\n\r\n\r\n    const refreshCandyMachineState = useCallback(async () => {\r\n        if (!anchorWallet) {\r\n          return;\r\n        }\r\n    \r\n        if (props.candyMachineId) {\r\n          try {\r\n            const cndy = await getCandyMachineState(\r\n              anchorWallet,\r\n              props.candyMachineId,\r\n              props.connection,\r\n            );\r\n            let active =\r\n              cndy?.state.goLiveDate?.toNumber() < new Date().getTime() / 1000;\r\n            let presale = false;\r\n            // whitelist mint?\r\n            if (cndy?.state.whitelistMintSettings) {\r\n              // is it a presale mint?\r\n              if (\r\n                cndy.state.whitelistMintSettings.presale &&\r\n                (!cndy.state.goLiveDate ||\r\n                  cndy.state.goLiveDate.toNumber() > new Date().getTime() / 1000)\r\n              ) {\r\n                presale = true;\r\n              }\r\n              // is there a discount?\r\n              if (cndy.state.whitelistMintSettings.discountPrice) {\r\n                setDiscountPrice(cndy.state.whitelistMintSettings.discountPrice);\r\n              } else {\r\n                setDiscountPrice(undefined);\r\n                // when presale=false and discountPrice=null, mint is restricted\r\n                // to whitelist users only\r\n                if (!cndy.state.whitelistMintSettings.presale) {\r\n                  cndy.state.isWhitelistOnly = true;\r\n                }\r\n              }\r\n              // retrieves the whitelist token\r\n              const mint = new anchor.web3.PublicKey(\r\n                cndy.state.whitelistMintSettings.mint,\r\n              );\r\n              const token = (await getAtaForMint(mint, anchorWallet.publicKey))[0];\r\n    \r\n              try {\r\n                const balance = await props.connection.getTokenAccountBalance(\r\n                  token,\r\n                );\r\n                let valid = parseInt(balance.value.amount) > 0;\r\n                // only whitelist the user if the balance > 0\r\n                setIsWhitelistUser(valid);\r\n                active = (presale && valid) || active;\r\n              } catch (e) {\r\n                setIsWhitelistUser(false);\r\n                // no whitelist user, no mint\r\n                if (cndy.state.isWhitelistOnly) {\r\n                  active = false;\r\n                }\r\n                console.log('There was a problem fetching whitelist token balance');\r\n                console.log(e);\r\n              }\r\n            }\r\n            // datetime to stop the mint?\r\n            if (cndy?.state.endSettings?.endSettingType.date) {\r\n              setEndDate(toDate(cndy.state.endSettings.number));\r\n              if (\r\n                cndy.state.endSettings.number.toNumber() <\r\n                new Date().getTime() / 1000\r\n              ) {\r\n                active = false;\r\n              }\r\n            }\r\n            // amount to stop the mint?\r\n            if (cndy?.state.endSettings?.endSettingType.amount) {\r\n              let limit = Math.min(\r\n                cndy.state.endSettings.number.toNumber(),\r\n                cndy.state.itemsAvailable,\r\n              );\r\n              if (cndy.state.itemsRedeemed < limit) {\r\n                setItemsRemaining(limit - cndy.state.itemsRedeemed);\r\n              } else {\r\n                setItemsRemaining(0);\r\n                cndy.state.isSoldOut = true;\r\n              }\r\n            } else {\r\n              setItemsRemaining(cndy.state.itemsRemaining);\r\n            }\r\n    \r\n            if (cndy.state.isSoldOut) {\r\n              active = false;\r\n            }\r\n    \r\n            setIsActive((cndy.state.isActive = active));\r\n            setIsPresale((cndy.state.isPresale = presale));\r\n            setCandyMachine(cndy);\r\n          } catch (e) {\r\n            console.log('There was a problem fetching Candy Machine state');\r\n            console.log(e);\r\n          }\r\n        }\r\n      }, [anchorWallet, props.candyMachineId, props.connection]);\r\n    \r\n      const onMint = async (\r\n        beforeTransactions: Transaction[] = [],\r\n        afterTransactions: Transaction[] = [],\r\n      ) => {\r\n        try {\r\n          setIsUserMinting(true);\r\n          document.getElementById('#identity')?.click();\r\n          if (wallet.connected && candyMachine?.program && wallet.publicKey) {\r\n            let mintOne = await mintOneToken(\r\n              candyMachine,\r\n              wallet.publicKey,\r\n              beforeTransactions,\r\n              afterTransactions,\r\n            );\r\n    \r\n            const mintTxId = mintOne[0];\r\n    \r\n            let status: any = { err: true };\r\n            if (mintTxId) {\r\n              status = await awaitTransactionSignatureConfirmation(\r\n                mintTxId,\r\n                props.txTimeout,\r\n                props.connection,\r\n                true,\r\n              );\r\n            }\r\n    \r\n            if (status && !status.err) {\r\n              // manual update since the refresh might not detect\r\n              // the change immediately\r\n              let remaining = itemsRemaining! - 1;\r\n              setItemsRemaining(remaining);\r\n              setIsActive((candyMachine.state.isActive = remaining > 0));\r\n              candyMachine.state.isSoldOut = remaining === 0;\r\n              setAlertState({\r\n                open: true,\r\n                message: 'Congratulations! Mint succeeded!',\r\n                severity: 'success',\r\n              });\r\n            } else {\r\n              setAlertState({\r\n                open: true,\r\n                message: 'Mint failed! Please try again!',\r\n                severity: 'error',\r\n              });\r\n            }\r\n          }\r\n        } catch (error: any) {\r\n          let message = error.msg || 'Minting failed! Please try again!';\r\n          if (!error.msg) {\r\n            if (!error.message) {\r\n              message = 'Transaction Timeout! Please try again.';\r\n            } else if (error.message.indexOf('0x137')) {\r\n              console.log(error);\r\n              message = `SOLD OUT!`;\r\n            } else if (error.message.indexOf('0x135')) {\r\n              message = `Insufficient funds to mint. Please fund your wallet.`;\r\n            }\r\n          } else {\r\n            if (error.code === 311) {\r\n              console.log(error);\r\n              message = `SOLD OUT!`;\r\n              window.location.reload();\r\n            } else if (error.code === 312) {\r\n              message = `Minting period hasn't started yet.`;\r\n            }\r\n          }\r\n    \r\n          setAlertState({\r\n            open: true,\r\n            message,\r\n            severity: 'error',\r\n          });\r\n          // updates the candy machine state to reflect the lastest\r\n          // information on chain\r\n          refreshCandyMachineState();\r\n        } finally {\r\n          setIsUserMinting(false);\r\n        }\r\n      };\r\n      \r\n      useEffect(() => {\r\n        refreshCandyMachineState();\r\n      }, [\r\n        anchorWallet,\r\n        props.candyMachineId,\r\n        props.connection,\r\n        refreshCandyMachineState,\r\n      ]);\r\n\r\n\r\n    return (\r\n        <>\r\n                {(\r\n            <div className=\"mint-section\">\r\n                <h1 className=\"mint-header\">Sibe Protocol <br /> white list </h1>\r\n                <div className=\"mint-volume volume\">\r\n                    <h4 className=\"mint-volume-h4 volume-h4\">Volume</h4>\r\n                    <span className=\"mint-volume-data volume-data\">{`${itemsRemaining || `96`}`}</span>\r\n                </div>\r\n                {candyMachine?.state.isActive &&\r\n                candyMachine?.state.gatekeeper &&\r\n                wallet.publicKey &&\r\n                wallet.signTransaction ? (\r\n                    <GatewayProvider\r\n                    wallet={{\r\n                        publicKey:\r\n                        wallet.publicKey ||\r\n                        new PublicKey(CANDY_MACHINE_PROGRAM),\r\n                        //@ts-ignore\r\n                        signTransaction: wallet.signTransaction,\r\n                    }}\r\n                    gatekeeperNetwork={\r\n                        candyMachine?.state?.gatekeeper?.gatekeeperNetwork\r\n                    }\r\n                    clusterUrl={rpcUrl}\r\n                    handleTransaction={async (transaction: Transaction) => {\r\n                        setIsUserMinting(true);\r\n                        const userMustSign = transaction.signatures.find(sig =>\r\n                        sig.publicKey.equals(wallet.publicKey!),\r\n                        );\r\n                        if (userMustSign) {\r\n                        setAlertState({\r\n                            open: true,\r\n                            message: 'Please sign one-time Civic Pass issuance',\r\n                            severity: 'info',\r\n                        });\r\n                        try {\r\n                            transaction = await wallet.signTransaction!(\r\n                            transaction,\r\n                            );\r\n                        } catch (e) {\r\n                            setAlertState({\r\n                            open: true,\r\n                            message: 'User cancelled signing',\r\n                            severity: 'error',\r\n                            });\r\n                            // setTimeout(() => window.location.reload(), 2000);\r\n                            setIsUserMinting(false);\r\n                            throw e;\r\n                        }\r\n                        } else {\r\n                        setAlertState({\r\n                            open: true,\r\n                            message: 'Refreshing Civic Pass',\r\n                            severity: 'info',\r\n                        });\r\n                        }\r\n                        try {\r\n                        await sendTransaction(\r\n                            props.connection,\r\n                            wallet,\r\n                            transaction,\r\n                            [],\r\n                            true,\r\n                            'confirmed',\r\n                        );\r\n                        setAlertState({\r\n                            open: true,\r\n                            message: 'Please sign minting',\r\n                            severity: 'info',\r\n                        });\r\n                        } catch (e) {\r\n                        setAlertState({\r\n                            open: true,\r\n                            message:\r\n                            'Solana dropped the transaction, please try again',\r\n                            severity: 'warning',\r\n                        });\r\n                        console.error(e);\r\n                        // setTimeout(() => window.location.reload(), 2000);\r\n                        setIsUserMinting(false);\r\n                        throw e;\r\n                        }\r\n                        await onMint();\r\n                    }}\r\n                    broadcastTransaction={false}\r\n                    options={{ autoShowModal: false }}\r\n                    >\r\n                    <MintButton\r\n                        candyMachine={candyMachine}\r\n                        isMinting={isUserMinting}\r\n                        setIsMinting={val => setIsUserMinting(val)}\r\n                        onMint={onMint}\r\n                        isActive={isActive || (isPresale && isWhitelistUser)}\r\n                    />\r\n                    </GatewayProvider>\r\n                ) : (\r\n                    <MintButton\r\n                    candyMachine={candyMachine}\r\n                    isMinting={isUserMinting}\r\n                    setIsMinting={val => setIsUserMinting(val)}\r\n                    onMint={onMint}\r\n                    isActive={isActive || (isPresale && isWhitelistUser)}\r\n                    />\r\n                )}\r\n                <img src={box} alt=\" \" className=\"box-img\" />\r\n            </div>)}\r\n        </>\r\n\r\n    )\r\n}","import * as anchor from '@project-serum/anchor';\r\nimport Collections from '../routes/Collections';\r\nimport MintComponent from '../components/MintComponent';\r\n\r\nexport interface HomeProps {\r\n  candyMachineId?: anchor.web3.PublicKey;\r\n  connection: anchor.web3.Connection;\r\n  txTimeout: number;\r\n  rpcHost: string;\r\n}\r\n\r\nexport default function HomePage (props:HomeProps) {\r\n    return (\r\n        <div className=\"body\">\r\n          <MintComponent candyMachineId={props.candyMachineId}\r\n                connection={props.connection}\r\n                txTimeout={props.txTimeout}\r\n                rpcHost={props.rpcHost}/>\r\n            <h1 className=\"collection-header\">SIBE NFT Collections</h1>\r\n            <Collections />\r\n        </div>\r\n    )\r\n}\r\n","import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';\r\n\r\nexport default function Overlay (props:any) {\r\n    return (\r\n        <div className=\"overlay\">\r\n             <nav className=\"overlay-menu\">\r\n                <ul className=\"overlay-menu-ul\">\r\n                    <li className=\"overlay-menu-li\">Staking</li>\r\n                    <li className=\"overlay-menu-li\"> <a href=\"https://sibe-finance.github.io/sibe-docs/\">Docs</a></li>\r\n                    <li className=\"overlay-menu-li\">Sibe paper</li>\r\n                    <li className=\"overlay-menu-li\">Sibe NFT</li>\r\n                    <li className=\"overlay-menu-li\">Roadmap</li>\r\n                </ul>\r\n            </nav>\r\n            <WalletMultiButton className=\"overlay-connect-wallet\"></WalletMultiButton>\r\n        </div>\r\n    )\r\n};\r\n","import './styles/App.css';\nimport { useMemo, useState, useRef } from 'react';\nimport * as anchor from '@project-serum/anchor';\n\nimport Header from './components/Header';\nimport Footer from './components/Footer';\nimport NFTMarketplace from './routes/NFTMarketplace';\nimport HomePage from './routes/HomePage';\nimport Collections from './routes/Collections';\n\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\nimport { Connection } from '@solana/web3.js';\nimport { Provider } from '@project-serum/anchor';\nimport Overlay from './components/Overlay';\n\nimport {\n  BrowserRouter,\n  Routes,\n  Route,\n} from \"react-router-dom\";\n\nimport {\n  getPhantomWallet,\n  getSlopeWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolletExtensionWallet,\n} from '@solana/wallet-adapter-wallets';\nimport { useWallet, WalletProvider, ConnectionProvider } from '@solana/wallet-adapter-react';\nimport { useOnClickOutside } from \"./hooks/useOnClickOutside\";\nimport { WalletModalProvider} from '@solana/wallet-adapter-react-ui';\nrequire('@solana/wallet-adapter-react-ui/styles.css');\n\n\nconst getCandyMachineId = (): anchor.web3.PublicKey | undefined => {\n  try {\n    const candyMachineId = new anchor.web3.PublicKey(\n      process.env.REACT_APP_CANDY_MACHINE_ID!,\n    );\n\n    return candyMachineId;\n  } catch (e) {\n    console.log('Failed to construct CandyMachineId', e);\n    return undefined;\n  }\n};\n\nconst candyMachineId = getCandyMachineId();\nconst network = process.env.REACT_APP_SOLANA_NETWORK as WalletAdapterNetwork;\nconst rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST!;\nconst connection = new anchor.web3.Connection(\n  rpcHost ? rpcHost : anchor.web3.clusterApiUrl('devnet'),\n);\n\nconst txTimeoutInMilliseconds = 30000;\n\nconst App = () => {\n  const [open, setOpen] = useState(false);\n  const node = useRef(); \n  useOnClickOutside(node, () => setOpen(false));\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getSlopeWallet(),\n      getSolletWallet({ network }),\n      getSolletExtensionWallet({ network }),\n    ],\n    [],\n  );\n\n  return (\n      <ConnectionProvider endpoint={endpoint}>\n      <WalletProvider wallets={wallets} autoConnect>\n        <WalletModalProvider>\n            <Header open={open} setOpen={setOpen}/>\n\n            {open ? <Overlay /> : <HomePage candyMachineId={candyMachineId}\n                connection={connection}\n                txTimeout={txTimeoutInMilliseconds}\n                rpcHost={rpcHost}/>}\n            { !open && <Footer />}\n        </WalletModalProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  );\n};\n\nexport default App;\n","import { useEffect } from 'react';\r\n\r\nexport const useOnClickOutside = (ref:any, handler:any) => {\r\n  useEffect(() => {\r\n     function listener (event:any){\r\n      if (!ref.current || ref.current.contains(event.target)) {\r\n        return;\r\n      }\r\n      handler(event);\r\n    };\r\n    document.addEventListener('mousedown', listener);\r\n    return () => {\r\n      document.removeEventListener('mousedown', listener);\r\n    };\r\n  },\r\n  [ref, handler],\r\n  );\r\n};\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from \"react-dom\";\nimport {\n  BrowserRouter,\n  Routes,\n  Route,\n} from \"react-router-dom\";\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\n\nimport './styles/index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App />\n  </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\nreportWebVitals();\n","import * as anchor from '@project-serum/anchor';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport {\n  LAMPORTS_PER_SOL,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\n\nexport interface AlertState {\n  open: boolean;\n  message: string;\n  severity: 'success' | 'info' | 'warning' | 'error' | undefined;\n}\n\nexport const toDate = (value?: anchor.BN) => {\n  if (!value) {\n    return;\n  }\n\n  return new Date(value.toNumber() * 1000);\n};\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n  asNumber: (val?: anchor.BN) => {\n    if (!val) {\n      return undefined;\n    }\n\n    return val.toNumber() / LAMPORTS_PER_SOL;\n  },\n};\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID =\n  new anchor.web3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const CIVIC = new anchor.web3.PublicKey(\n  'gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs',\n);\n\nexport const getAtaForMint = async (\n  mint: anchor.web3.PublicKey,\n  buyer: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  );\n};\n\nexport const getNetworkExpire = async (\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [gatekeeperNetwork.toBuffer(), Buffer.from('expire')],\n    CIVIC,\n  );\n};\n\nexport const getNetworkToken = async (\n  wallet: anchor.web3.PublicKey,\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [\n      wallet.toBuffer(),\n      Buffer.from('gateway'),\n      Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\n      gatekeeperNetwork.toBuffer(),\n    ],\n    CIVIC,\n  );\n};\n\nexport function createAssociatedTokenAccountInstruction(\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n}\n","import {\n  Keypair,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from '@solana/web3.js';\n\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string,\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][],\n): Promise<(string | undefined)[]> {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids: string[] = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          'single',\n        );\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const { txs } = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          'single',\n        );\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      'Died on ',\n      stopPoint,\n      'retrying from instruction',\n      instructions[stopPoint],\n      'instructions length is',\n      instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: any,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = 'singleGossip',\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator,\n  beforeTransactions: Transaction[] = [],\n  afterTransactions: Transaction[] = [],\n): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = beforeTransactions;\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n  unsignedTxns.push(...afterTransactions);\n\n  const partiallySignedTransactions = unsignedTxns.filter(t =>\n    t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  const fullySignedTransactions = unsignedTxns.filter(\n    t => !t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  let signedTxns = await wallet.signAllTransactions(\n    partiallySignedTransactions,\n  );\n  signedTxns = fullySignedTransactions.concat(signedTxns);\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  console.log(\n    'Signed txns length',\n    signedTxns.length,\n    'vs handed in length',\n    instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise.then(({ txid, slot }) =>\n          successCallback(txid, i),\n        );\n        pendingTxns.push(signedTxnPromise);\n      } catch (e) {\n        console.log('Failed at txn index:', i);\n        console.log('Caught failure:', e);\n\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          return {\n            number: i,\n            txs: await Promise.all(pendingTxns),\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    const result = await Promise.all(pendingTxns);\n    return { number: signedTxns.length, txs: result };\n  }\n\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[] | Transaction,\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction: Transaction;\n  if (instructions instanceof Transaction) {\n    transaction = instructions;\n  } else {\n    transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = (\n      block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n\n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n    }\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'recent',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err: any) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            console.log('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import * as anchor from '@project-serum/anchor';\n\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\nimport {\n  SystemProgram,\n  Transaction,\n  SYSVAR_SLOT_HASHES_PUBKEY,\n} from '@solana/web3.js';\nimport { sendTransactions, SequenceType } from './connection';\n\nimport {\n  CIVIC,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from './utils';\n\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\n  'cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ',\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',\n);\n\ninterface CandyMachineState {\n  authority: anchor.web3.PublicKey;\n  itemsAvailable: number;\n  itemsRedeemed: number;\n  itemsRemaining: number;\n  treasury: anchor.web3.PublicKey;\n  tokenMint: anchor.web3.PublicKey;\n  isSoldOut: boolean;\n  isActive: boolean;\n  isPresale: boolean;\n  isWhitelistOnly: boolean;\n  goLiveDate: anchor.BN;\n  price: anchor.BN;\n  gatekeeper: null | {\n    expireOnUse: boolean;\n    gatekeeperNetwork: anchor.web3.PublicKey;\n  };\n  endSettings: null | {\n    number: anchor.BN;\n    endSettingType: any;\n  };\n  whitelistMintSettings: null | {\n    mode: any;\n    mint: anchor.web3.PublicKey;\n    presale: boolean;\n    discountPrice: null | anchor.BN;\n  };\n  hiddenSettings: null | {\n    name: string;\n    uri: string;\n    hash: Uint8Array;\n  };\n  retainAuthority: boolean;\n}\n\nexport interface CandyMachineAccount {\n  id: anchor.web3.PublicKey;\n  program: anchor.Program;\n  state: CandyMachineState;\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  queryStatus = false,\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log('Returning status', status);\n  return status;\n};\n\nconst createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\nexport const getCandyMachineState = async (\n  anchorWallet: anchor.Wallet,\n  candyMachineId: anchor.web3.PublicKey,\n  connection: anchor.web3.Connection,\n): Promise<CandyMachineAccount> => {\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'processed',\n  });\n\n  const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);\n\n  const program = new anchor.Program(idl!, CANDY_MACHINE_PROGRAM, provider);\n\n  const state: any = await program.account.candyMachine.fetch(candyMachineId);\n  const itemsAvailable = state.data.itemsAvailable.toNumber();\n  const itemsRedeemed = state.itemsRedeemed.toNumber();\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n  return {\n    id: candyMachineId,\n    program,\n    state: {\n      authority: state.authority,\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      isSoldOut: itemsRemaining === 0,\n      isActive: false,\n      isPresale: false,\n      isWhitelistOnly: false,\n      goLiveDate: state.data.goLiveDate,\n      treasury: state.wallet,\n      tokenMint: state.tokenMint,\n      gatekeeper: state.data.gatekeeper,\n      endSettings: state.data.endSettings,\n      whitelistMintSettings: state.data.whitelistMintSettings,\n      hiddenSettings: state.data.hiddenSettings,\n      price: state.data.price,\n      retainAuthority: state.data.retainAuthority,\n    },\n  };\n};\n\nconst getMasterEdition = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getCandyMachineCreator = async (\n  candyMachine: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from('candy_machine'), candyMachine.toBuffer()],\n    CANDY_MACHINE_PROGRAM,\n  );\n};\n\nexport const getCollectionPDA = async (\n  candyMachineAddress: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from('collection'), candyMachineAddress.toBuffer()],\n    CANDY_MACHINE_PROGRAM,\n  );\n};\n\nexport interface CollectionData {\n  mint: anchor.web3.PublicKey;\n  candyMachine: anchor.web3.PublicKey;\n}\n\nexport const getCollectionAuthorityRecordPDA = async (\n  mint: anchor.web3.PublicKey,\n  newAuthority: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('collection_authority'),\n        newAuthority.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const mintOneToken = async (\n  candyMachine: CandyMachineAccount,\n  payer: anchor.web3.PublicKey,\n  beforeTransactions: Transaction[] = [],\n  afterTransactions: Transaction[] = [],\n): Promise<(string | undefined)[]> => {\n  const mint = anchor.web3.Keypair.generate();\n\n  const userTokenAccountAddress = (\n    await getAtaForMint(mint.publicKey, payer)\n  )[0];\n\n  const userPayingAccountAddress = candyMachine.state.tokenMint\n    ? (await getAtaForMint(candyMachine.state.tokenMint, payer))[0]\n    : payer;\n\n  const candyMachineAddress = candyMachine.id;\n\n  const remainingAccounts = [];\n  const signers: anchor.web3.Keypair[] = [mint];\n  const cleanupInstructions = [];\n  const instructions = [\n    anchor.web3.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: mint.publicKey,\n      space: MintLayout.span,\n      lamports:\n        await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\n          MintLayout.span,\n        ),\n      programId: TOKEN_PROGRAM_ID,\n    }),\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      0,\n      payer,\n      payer,\n    ),\n    createAssociatedTokenAccountInstruction(\n      userTokenAccountAddress,\n      payer,\n      payer,\n      mint.publicKey,\n    ),\n    Token.createMintToInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      userTokenAccountAddress,\n      payer,\n      [],\n      1,\n    ),\n  ];\n\n  if (candyMachine.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (\n        await getNetworkToken(\n          payer,\n          candyMachine.state.gatekeeper.gatekeeperNetwork,\n        )\n      )[0],\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (candyMachine.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkExpire(\n            candyMachine.state.gatekeeper.gatekeeperNetwork,\n          )\n        )[0],\n        isWritable: false,\n        isSigner: false,\n      });\n    }\n  }\n  if (candyMachine.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(\n      candyMachine.state.whitelistMintSettings.mint,\n    );\n\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists =\n        await candyMachine.program.provider.connection.getAccountInfo(\n          whitelistToken,\n        );\n      if (exists) {\n        instructions.push(\n          Token.createApproveInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            whitelistBurnAuthority.publicKey,\n            payer,\n            [],\n            1,\n          ),\n        );\n        cleanupInstructions.push(\n          Token.createRevokeInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            payer,\n            [],\n          ),\n        );\n      }\n    }\n  }\n\n  if (candyMachine.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false,\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true,\n    });\n\n    instructions.push(\n      Token.createApproveInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        transferAuthority.publicKey,\n        payer,\n        [],\n        candyMachine.state.price.toNumber(),\n      ),\n    );\n    cleanupInstructions.push(\n      Token.createRevokeInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        payer,\n        [],\n      ),\n    );\n  }\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\n    candyMachineAddress,\n  );\n\n  console.log(remainingAccounts.map(rm => rm.pubkey.toBase58()));\n  instructions.push(\n    await candyMachine.program.instruction.mintNft(creatorBump, {\n      accounts: {\n        candyMachine: candyMachineAddress,\n        candyMachineCreator,\n        payer: payer,\n        wallet: candyMachine.state.treasury,\n        mint: mint.publicKey,\n        metadata: metadataAddress,\n        masterEdition,\n        mintAuthority: payer,\n        updateAuthority: payer,\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n        rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n        recentBlockhashes: SYSVAR_SLOT_HASHES_PUBKEY,\n        instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n      },\n      remainingAccounts:\n        remainingAccounts.length > 0 ? remainingAccounts : undefined,\n    }),\n  );\n\n  const [collectionPDA] = await getCollectionPDA(candyMachineAddress);\n  const collectionPDAAccount =\n    await candyMachine.program.provider.connection.getAccountInfo(\n      collectionPDA,\n    );\n\n  if (collectionPDAAccount && candyMachine.state.retainAuthority) {\n    try {\n      const collectionData =\n        (await candyMachine.program.account.collectionPda.fetch(\n          collectionPDA,\n        )) as CollectionData;\n      console.log(collectionData);\n      const collectionMint = collectionData.mint;\n      const collectionAuthorityRecord = await getCollectionAuthorityRecordPDA(\n        collectionMint,\n        collectionPDA,\n      );\n      console.log(collectionMint);\n      if (collectionMint) {\n        const collectionMetadata = await getMetadata(collectionMint);\n        const collectionMasterEdition = await getMasterEdition(collectionMint);\n        console.log('Collection PDA: ', collectionPDA.toBase58());\n        console.log('Authority: ', candyMachine.state.authority.toBase58());\n        instructions.push(\n          await candyMachine.program.instruction.setCollectionDuringMint({\n            accounts: {\n              candyMachine: candyMachineAddress,\n              metadata: metadataAddress,\n              payer: payer,\n              collectionPda: collectionPDA,\n              tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n              instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n              collectionMint,\n              collectionMetadata,\n              collectionMasterEdition,\n              authority: candyMachine.state.authority,\n              collectionAuthorityRecord,\n            },\n          }),\n        );\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  const instructionsMatrix: anchor.web3.TransactionInstruction[][] = [];\n  const signersMatrix: anchor.web3.Keypair[][] = [];\n\n  const state = candyMachine.state;\n  const txnEstimate =\n    892 +\n    (collectionPDAAccount && state.retainAuthority ? 182 : 0) +\n    (state.tokenMint ? 177 : 0) +\n    (state.whitelistMintSettings ? 33 : 0) +\n    (state.whitelistMintSettings?.mode?.burnEveryTime ? 145 : 0) +\n    (state.gatekeeper ? 33 : 0) +\n    (state.gatekeeper?.expireOnUse ? 66 : 0);\n\n  const INIT_INSTRUCTIONS_LENGTH = 4;\n  const INIT_SIGNERS_LENGTH = 1;\n\n  console.log('Transaction estimate: ', txnEstimate);\n  if (txnEstimate > 1230) {\n    const initInstructions = instructions.splice(0, INIT_INSTRUCTIONS_LENGTH);\n    console.log(initInstructions);\n    instructionsMatrix.push(initInstructions);\n    const initSigners = signers.splice(0, INIT_SIGNERS_LENGTH);\n    signersMatrix.push(initSigners);\n  }\n\n  instructionsMatrix.push(instructions);\n  signersMatrix.push(signers);\n\n  if (cleanupInstructions.length > 0) {\n    instructionsMatrix.push(cleanupInstructions);\n    signersMatrix.push([]);\n  }\n\n  try {\n    return (\n      await sendTransactions(\n        candyMachine.program.provider.connection,\n        candyMachine.program.provider.wallet,\n        instructionsMatrix,\n        signersMatrix,\n        SequenceType.StopOnFailure,\n        'singleGossip',\n        () => {},\n        () => false,\n        undefined,\n        beforeTransactions,\n        afterTransactions,\n      )\n    ).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n"],"sourceRoot":""}