{"version":3,"sources":["components/BurgerButton.tsx","img/github.svg","img/telegram.svg","img/twitter.svg","img/discord.svg","components/Header.tsx","components/Footer.tsx","components/Overlay.tsx","hooks/useOnClickOutside.ts","routes/NftCard.tsx","components/NFTItem.tsx","components/Loader.tsx","routes/NFTMarketplace.tsx","hooks/useFetch.ts","routes/Collections.tsx","components/MintButton.tsx","img/box.svg","components/MintComponent.tsx","routes/HomePage.tsx","App.tsx","reportWebVitals.ts","index.tsx","scripts/utils.ts","scripts/connection.tsx","scripts/candy-machine.ts"],"names":["Burger","props","className","onClick","setOpen","open","style","transform","width","opacity","Header","useWallet","backgroundColor","href","staking","nft","src","github","alt","telegram","twitter","discord","Footer","Overlay","NftCard","params","useParams","token","useLocation","state","attr","key","value","collectionId","img","console","log","price","toFixed","id","name","owner","slice","map","at","index","NFTMarketplace","rest","useState","mint","token_add","to","Loader","connectedNft","nftCollection","setNftCollection","loader","setLoader","get","url","Promise","resolve","reject","fetch","then","response","json","data","catch","error","useFetch","collection","useEffect","color","link_img","seller_address","attributes","Collections","coll","result","collections","items","MintButton","onMint","candyMachine","isMinting","setIsMinting","isActive","wallet","connection","useConnection","verified","setVerified","useGateway","requestGatewayToken","gatewayStatus","webSocketSubscriptionId","setWebSocketSubscriptionId","clicked","setClicked","a","removeAccountChangeListener","previousGatewayStatus","ref","useRef","current","usePrevious","fromStates","GatewayStatus","NOT_REQUESTED","REFRESH_TOKEN_REQUIRED","invalidToStates","UNKNOWN","find","disabled","gatekeeper","network","gatekeeperNetwork","toBase58","ACTIVE","findGatewayToken","publicKey","gatewayToken","isValid","window","getGatewayTokenAddressForOwnerAndGatekeeperNetwork","gatewayTokenAddress","onGatewayTokenChange","Error","isSoldOut","isPresale","isWhitelistOnly","formatNumber","asNumber","MintComponent","message","severity","undefined","setAlertState","setCandyMachine","setDiscountPrice","setEndDate","isUserMinting","setIsUserMinting","setIsActive","itemsRemaining","setItemsRemaining","isWhitelistUser","setIsWhitelistUser","setIsPresale","rpcUrl","rpcHost","anchorWallet","useMemo","signAllTransactions","signTransaction","refreshCandyMachineState","useCallback","candyMachineId","getCandyMachineState","cndy","active","goLiveDate","toNumber","Date","getTime","presale","whitelistMintSettings","discountPrice","anchor","PublicKey","getAtaForMint","getTokenAccountBalance","balance","valid","parseInt","amount","endSettings","endSettingType","date","toDate","number","limit","Math","min","itemsAvailable","itemsRedeemed","beforeTransactions","afterTransactions","document","getElementById","click","connected","program","mintOneToken","mintOne","mintTxId","status","err","awaitTransactionSignatureConfirmation","txTimeout","remaining","msg","code","location","reload","indexOf","CANDY_MACHINE_PROGRAM","clusterUrl","handleTransaction","transaction","signatures","sig","equals","sendTransaction","broadcastTransaction","options","autoShowModal","val","box","HomePage","require","process","e","getCandyMachineId","Connection","App","handler","node","listener","event","contains","target","addEventListener","removeEventListener","endpoint","clusterApiUrl","wallets","getPhantomWallet","getSolflareWallet","getSlopeWallet","getSolletWallet","getSolletExtensionWallet","ConnectionProvider","WalletProvider","autoConnect","path","element","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","numberFormater","Intl","NumberFormat","minimumFractionDigits","maximumFractionDigits","format","LAMPORTS_PER_SOL","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","CIVIC","buyer","findProgramAddress","toBuffer","TOKEN_PROGRAM_ID","getNetworkExpire","Buffer","from","getNetworkToken","SequenceType","getErrorForTransaction","txid","confirmTransaction","getParsedConfirmedTransaction","tx","errors","meta","logMessages","forEach","m","regex","exec","lastIndex","length","push","sendTransactions","instructionSet","signersSet","sequenceType","Parallel","commitment","successCallback","ind","failCallback","block","WalletNotConnectedError","unsignedTxns","getRecentBlockhash","i","instructions","signers","Transaction","instruction","add","recentBlockhash","blockhash","setSigners","s","partialSign","partiallySignedTransactions","filter","t","fullySignedTransactions","signedTxns","concat","pendingTxns","signedTxnPromise","sendSignedTransaction","signedTransaction","slot","StopOnFailure","all","txs","awaitConfirmation","includesFeePayer","rawTransaction","serialize","skipPreflight","sendRawTransaction","DEFAULT_TIMEOUT","confirmation","getUnixTs","timeout","startTime","done","sleep","simulateResult","simulateTransaction","logs","line","startsWith","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","toString","args","encoding","_rpcRequest","res","queryStatus","confirmations","subId","setTimeout","onSignature","context","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms","TOKEN_METADATA_PROGRAM_ID","createAssociatedTokenAccountInstruction","associatedTokenAddress","payer","walletAddress","splTokenMintAddress","keys","pubkey","isSigner","isWritable","SystemProgram","programId","SYSVAR_RENT_PUBKEY","TransactionInstruction","provider","preflightCommitment","fetchIdl","idl","account","authority","treasury","tokenMint","hiddenSettings","retainAuthority","getMasterEdition","getMetadata","getCandyMachineCreator","getCollectionPDA","candyMachineAddress","getCollectionAuthorityRecordPDA","newAuthority","Keypair","generate","userTokenAccountAddress","userPayingAccountAddress","remainingAccounts","cleanupInstructions","MintLayout","span","getMinimumBalanceForRentExemption","fromPubkey","newAccountPubkey","space","lamports","createAccount","Token","createInitMintInstruction","createMintToInstruction","expireOnUse","whitelistToken","mode","burnEveryTime","whitelistBurnAuthority","getAccountInfo","createApproveInstruction","createRevokeInstruction","transferAuthority","metadataAddress","masterEdition","candyMachineCreator","creatorBump","rm","mintNft","accounts","metadata","mintAuthority","updateAuthority","tokenMetadataProgram","tokenProgram","systemProgram","rent","clock","SYSVAR_CLOCK_PUBKEY","recentBlockhashes","SYSVAR_SLOT_HASHES_PUBKEY","instructionSysvarAccount","SYSVAR_INSTRUCTIONS_PUBKEY","collectionPDA","collectionPDAAccount","collectionPda","collectionData","collectionMint","collectionAuthorityRecord","collectionMetadata","collectionMasterEdition","setCollectionDuringMint","instructionsMatrix","signersMatrix","txnEstimate","INIT_INSTRUCTIONS_LENGTH","INIT_SIGNERS_LENGTH","initInstructions","splice","initSigners"],"mappings":"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","file":"static/js/main.4f208df2.chunk.js","sourcesContent":["export default function Burger (props:any) {\r\n    return (\r\n        <button className=\"burger\" onClick={() => props.setOpen(!props.open)}>\r\n            <div style={{transform:  props.open ? 'rotate(45deg)' : 'translateY(-6px)', width : \"28px\"}}></div>\r\n            <div style={{transform:  props.open ? 'translateX(20px)' : 'scaleX(1)', opacity: props.open ? '0' : '1', width : \"20px\"}}></div>\r\n            <div style={{transform:  props.open ? 'rotate(-45deg)' : 'translateY(6px)', width : \"28px\"}}></div>\r\n        </button>\r\n    )\r\n};","export default __webpack_public_path__ + \"static/media/github.6cd3efeb.svg\";","export default __webpack_public_path__ + \"static/media/telegram.c2ac02ad.svg\";","export default __webpack_public_path__ + \"static/media/twitter.deedb5ed.svg\";","export default __webpack_public_path__ + \"static/media/discord.2fd207e1.svg\";","import \"../styles/HeaderFooter.css\";\r\nimport Burger from \"./BurgerButton\";\r\nimport github from \"../img/github.svg\";\r\nimport telegram from \"../img/telegram.svg\";\r\nimport twitter from \"../img/twitter.svg\";\r\nimport discord from \"../img/discord.svg\";\r\nimport { useWallet } from '@solana/wallet-adapter-react';\r\nimport { WalletMultiButton } from '@solana/wallet-adapter-react-ui';\r\n\r\n\r\nexport default function Header (props:any) {\r\n    const wallet = useWallet();\r\n\r\n    return (\r\n        <div className=\"header\" style={{backgroundColor: props.open && \"#191919\"  }}>\r\n            <a href=\"|\" className=\"header-logo\">\r\n            </a>\r\n            <nav className=\"header-menu\">\r\n                <ul className=\"header-menu-ul\">\r\n                    <li className=\"header-menu-li\" onClick={props.staking}>Staking</li>\r\n                    <li className=\"header-menu-li\"> <a href=\"https://sibe-finance.github.io/sibe-docs/\">Docs</a></li>\r\n                    <li className=\"header-menu-li\">Sibe paper</li>\r\n                    <li className=\"header-menu-li\" onClick={props.nft}>Sibe NFT</li>\r\n                    <li className=\"header-menu-li\">Roadmap</li>\r\n                </ul>\r\n            </nav>\r\n            <nav className=\"header-socials\">\r\n                <ul className=\"header-socials-ul\">\r\n                    <li className=\"header-socials-li\"><a href=\"github\"><img src={github} alt=\"https://github.com/sibe-finance\" /></a></li>\r\n                    <li className=\"header-socials-li\"><a href=\"telegram\"><img src={telegram} alt=\"https://t.me/SIBEprotocol\" /></a></li>\r\n                    <li className=\"header-socials-li\"><a href=\"twitter\"><img src={twitter} alt=\"https://twitter.com/SibeGameFi?t=P1crNdFCL3F3p71_31zpLA&s=09\" /></a></li>\r\n                    <li className=\"header-socials-li\"><a href=\"discord\"><img src={discord} alt=\"https://discord.com/invite/yE3Q6mG9De\" /></a></li>\r\n                </ul>\r\n            </nav>\r\n            <WalletMultiButton className=\"header-connect-wallet\"></WalletMultiButton>\r\n            <Burger open={props.open} setOpen={props.setOpen} />\r\n        </div>\r\n    )\r\n};","import \"../styles/HeaderFooter.css\";\r\nimport github from \"../img/github.svg\";\r\nimport telegram from \"../img/telegram.svg\";\r\nimport twitter from \"../img/twitter.svg\";\r\nimport discord from \"../img/discord.svg\";\r\n\r\n\r\nexport default function Footer () {\r\n    return <div className=\"footer\"> \r\n        <nav className=\"footer-socials\">\r\n            <ul className=\"footer-socials-ul\">\r\n                <li className=\"footer-socials-li\"><a href=\"https://github.com/sibe-finance\"><img src={github} alt=\"github\" /></a></li>\r\n                <li className=\"footer-socials-li\"><a href=\"https://t.me/SIBEprotocol\"><img src={telegram} alt=\"telegram\" /></a></li>\r\n                <li className=\"footer-socials-li\"><a href=\"https://twitter.com/SibeGameFi?t=P1crNdFCL3F3p71_31zpLA&s=09\"><img src={twitter} alt=\"twitter\" /></a></li>\r\n                <li className=\"footer-socials-li\"><a href=\"https://discord.com/invite/yE3Q6mG9De\"><img src={discord} alt=\"discord\" /></a></li>\r\n            </ul>\r\n        </nav>\r\n        <nav className=\"footer-menu\">\r\n            <ul className=\"footer-menu-ul\">\r\n            <li className=\"footer-menu-li\"><a href=\"https://github.com/sibe-finance\">Github</a></li>\r\n            <li className=\"footer-menu-li\"><a href=\"/\">Sibe NFT</a></li>\r\n            <li className=\"footer-menu-li\"><a href=\"/\">Docs</a></li>\r\n            <li className=\"footer-menu-li\"><a href=\"https://sibe-finance.github.io/sibe-docs/\">Cispracs</a></li>\r\n            <li className=\"footer-menu-li\"><a href=\"/\">Roadmap</a></li>\r\n            </ul>\r\n        </nav>\r\n    </div>\r\n}","import { WalletMultiButton } from '@solana/wallet-adapter-react-ui';\r\n\r\nexport default function Overlay (props:any) {\r\n    return (\r\n        <div className=\"overlay\">\r\n             <nav className=\"overlay-menu\">\r\n                <ul className=\"overlay-menu-ul\">\r\n                    <li className=\"overlay-menu-li\">Staking</li>\r\n                    <li className=\"overlay-menu-li\"> <a href=\"https://sibe-finance.github.io/sibe-docs/\">Docs</a></li>\r\n                    <li className=\"overlay-menu-li\">Sibe paper</li>\r\n                    <li className=\"overlay-menu-li\">Sibe NFT</li>\r\n                    <li className=\"overlay-menu-li\">Roadmap</li>\r\n                </ul>\r\n            </nav>\r\n            <WalletMultiButton className=\"overlay-connect-wallet\"></WalletMultiButton>\r\n        </div>\r\n    )\r\n};\r\n","import { useEffect } from 'react';\r\n\r\nexport const useOnClickOutside = (ref:any, handler:any) => {\r\n  useEffect(() => {\r\n     function listener (event:any){\r\n      if (!ref.current || ref.current.contains(event.target)) {\r\n        return;\r\n      }\r\n      handler(event);\r\n    };\r\n    document.addEventListener('mousedown', listener);\r\n    return () => {\r\n      document.removeEventListener('mousedown', listener);\r\n    };\r\n  },\r\n  [ref, handler],\r\n  );\r\n};\r\n","import { useParams } from \"react-router-dom\";\r\nimport { useLocation } from \"react-router-dom\";\r\n\r\n\r\nexport default function NftCard() {\r\n    const params = useParams();\r\n    const location:any = useLocation();\r\n    const token = location.state.token;\r\n    const attr = [ \r\n        {key : \"Background\", value: \"Base Background\"},\r\n        {key : \"Skin\", value: \"Human\"},\r\n        {key : \"Cloth\", value: \"Jacket\"},\r\n        {key : \"Necklace\", value:\"Flower Necklace\"},\r\n        {key : \"Mouth\", value: \"Plague Mask\"},\r\n        {key : \"Eyes\", value: \"Red Eyes\"},\r\n        {key : \"Hair\", value: \"Pigtails\"},\r\n        {key : \"Type\", value: \"Aurorian\"},\r\n]\r\n\r\n    return (\r\n        <div className=\"body\">\r\n            <h1 className=\"nft-card-h1\">{params.collectionId}</h1>\r\n            <div className=\"nft-card-wrapper\">\r\n                <div className=\"nft-card-container \">\r\n                    <img src={token.img} alt=\"\" className=\"nft-card-img\" />\r\n                    <button className=\"nft-card-buy\" onClick={()=>console.log(attr)}>Buy now <span> {token.price.toFixed(2)} SOL</span></button>\r\n                </div>\r\n                <div className=\"nft-card-container\">\r\n                    <span className=\"nft-card-id\"># <span> {token.id} </span></span>\r\n                    <h2 className=\"nft-card-name\">{token.name}</h2>\r\n                    <h4 className=\"nft-card-collection\">{params.collectionId}</h4>\r\n                    <span className=\"nft-card-owner\">\r\n                        Owned by <h4 className=\"nft-card-owner-address\">{token.owner.slice(0, 26) + '...'}</h4>\r\n                    </span>\r\n                    <div className=\"nft-card-attributes\">\r\n                       {attr.map((at, index) => {\r\n                            return (<div className=\"attributes-wrapper\" key={index}>\r\n                                <span className=\"rarity\">10% rarity</span>\r\n                                <h4 className=\"attr-name\">{at.key}</h4>\r\n                                <h4 className=\"attr-data\">{at.value}</h4>\r\n                            </div>)\r\n                        })}\r\n                    </div>\r\n                    <button className=\"mobile-nft-card-buy\" onClick={()=>console.log(attr)}>Buy now <span> {token.price.toFixed(2)} SOL</span></button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import {useState} from \"react\";\r\nimport {Link} from \"react-router-dom\";\r\n\r\nexport default function NFTMarketplace (props: any) {\r\n    const {collectionId, ...rest} = props;\r\n    const [token, settoken]= useState({...rest})\r\n\r\n    const mint = props.token_add;\r\n    return (\r\n        <Link to={`/${props.collectionId}/${props.name}`} state={{token : token}} className=\"nft-item-wrapper\">\r\n            <img src={props.img} alt=\"nft-item\" className=\"nft-item-img\" />\r\n            <h3 className=\"nft-item-name\">{props.name}</h3>\r\n            <div className=\"nft-item-token-address\">\r\n                <div className=\"nft-item-logo\"></div>\r\n                <p className=\"nft-item-address\">{mint.slice(0, 5) + '...' + mint.slice(-5)}</p>\r\n            </div>\r\n        </Link>\r\n    )\r\n}\r\n","export default function Loader() {\r\n    return (\r\n        <div className=\"loader-wrapper\">\r\n            <div className=\"loader\"></div>\r\n            <div className=\"loader\"></div>\r\n            <div className=\"loader\"></div>\r\n        </div>\r\n    )\r\n}","/* eslint-disable react-hooks/exhaustive-deps */\r\nimport NFTItem from '../components/NFTItem';\r\nimport useFetch from '../hooks/useFetch';\r\nimport React, {useState, useEffect} from 'react';\r\nimport { useWallet } from '@solana/wallet-adapter-react';\r\nimport { useParams } from \"react-router-dom\";\r\nimport Loader from \"../components/Loader\";\r\n\r\nexport default function NFTMarketplace () {\r\n    const [connectedNft, setConnectedNft] = useState(false);\r\n    const [nftCollection, setNftCollection] = useState<any[]>([]);\r\n    const wallet = useWallet();\r\n    const {get, loader} = useFetch();\r\n    const params = useParams();\r\n    const collection = params.collectionId;\r\n\r\n    useEffect(() => {\r\n      get(`https://qzlsklfacc.medianetwork.cloud/nft_for_sale?collection=${collection}`)\r\n      .then((data:any) => {\r\n        console.log(data);\r\n        setNftCollection(data);\r\n        return nftCollection;\r\n      })\r\n      .catch(error => console.error(error)) \r\n    }, []) \r\n\r\n    const myNftButtonHandler = (event: React.MouseEvent<HTMLButtonElement>) => {\r\n        setConnectedNft(true);\r\n        event.preventDefault();\r\n    };\r\n\r\n    const nftButtonHandler = (event: React.MouseEvent<HTMLButtonElement>) => {\r\n        setConnectedNft(false);\r\n        event.preventDefault();\r\n    };\r\n\r\n    return (\r\n\r\n        <div className=\"body\">\r\n            <div className=\"nft-marketplace-wrapper\">\r\n                <h1 className=\"nft-marketplace-header\">{params.collectionId}</h1>\r\n                <div className=\"nft-marketplace-items-wrapper\">\r\n                    <div className=\"decor\"></div>\r\n                    <h2 style={{color: \"white\"}}>{loader ? <Loader /> : \"\"}</h2>\r\n                    {connectedNft && <div className=\"nft-items-wrapper\">\r\n                    </div> }\r\n                    { !connectedNft && <div className=\"nft-items-wrapper\">\r\n                    {nftCollection?.map((nft, index) => {\r\n                         return <NFTItem id={nft.id} token_add={nft.token_add} price={nft.price} img={nft.link_img} name={nft.name} owner={nft.seller_address} attr={nft.attributes} collectionId={params.collectionId} key={index} />\r\n                    }\r\n                    )}\r\n                    </div>}\r\n\r\n                    <div className=\"arrows\">\r\n\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n","import {useState} from \"react\"\r\n\r\nexport default function useFetch() {\r\n  const [loader, setLoader] = useState(true)\r\n\r\n  function get(url:string) {\r\n    return new Promise((resolve, reject) => {\r\n      fetch (url)\r\n      .then(response => response.json())\r\n      .then(data => {\r\n        if (!data) {\r\n          setLoader(false)\r\n          reject(data)\r\n        }\r\n        setLoader(false)\r\n        resolve(data)\r\n      })\r\n      .catch(error => {\r\n        setLoader(false)\r\n        reject(error)\r\n      })\r\n    })\r\n  }\r\n\r\n  return {get, loader}\r\n};\r\n","import { useState } from 'react';\r\nimport {\r\n    Link\r\n  } from \"react-router-dom\";\r\nimport coll from '../collections.json';\r\n\r\nexport default function Collections(props:any) {\r\n    const [collections, setCollections] = useState(coll.result.data);\r\n    \r\n    return (\r\n        <div className=\"collections-wrapper\">\r\n        {collections?.map((collection)=> (\r\n          <Link to={`${collection.name}`} key={collection.name} className=\"collection-item-wrapper\">\r\n            <div className=\"collection-item-logo\"></div>\r\n            <h3 className=\"collection-item-header\">{collection.name}</h3>\r\n            <div className=\"collection-item-volume volume\">\r\n                    <h4 className=\"collection-item-volume-h4 volume-h4\">Volume</h4>\r\n                    <span className=\"collection-item-volume-data volume-data\"> {collection.items} </span>\r\n                </div>\r\n          </Link>\r\n        ))}\r\n      </div>\r\n    );\r\n}","import { CandyMachineAccount } from '../scripts/candy-machine';\nimport { GatewayStatus, useGateway } from '@civic/solana-gateway-react';\nimport { useEffect, useState, useRef } from 'react';\nimport { useConnection, useWallet } from '@solana/wallet-adapter-react';\nimport {\n  findGatewayToken,\n  getGatewayTokenAddressForOwnerAndGatekeeperNetwork,\n  onGatewayTokenChange,\n  removeAccountChangeListener,\n} from '@identity.com/solana-gateway-ts';\nimport { formatNumber } from '../scripts/utils';\n\n\nexport const MintButton = ({\n  onMint,\n  candyMachine,\n  isMinting,\n  setIsMinting,\n  isActive,\n}: {\n  onMint: () => Promise<void>;\n  candyMachine?: CandyMachineAccount;\n  isMinting: boolean;\n  setIsMinting: (val: boolean) => void;\n  isActive: boolean;\n}) => {\n  const wallet = useWallet();\n  const connection = useConnection();\n  const [verified, setVerified] = useState(false);\n  const { requestGatewayToken, gatewayStatus } = useGateway();\n  const [webSocketSubscriptionId, setWebSocketSubscriptionId] = useState(-1);\n  const [clicked, setClicked] = useState(false);\n\n  const getMintButtonContent = () => {\n    if (candyMachine?.state.isSoldOut) {\n      return 'SOLD OUT';\n    } else if (isMinting) {\n      return 'Loading...';\n    } else if (\n      candyMachine?.state.isPresale ||\n      candyMachine?.state.isWhitelistOnly\n    ) {\n      return 'WHITELIST MINT';\n    }\n\n    return `Buy now ${formatNumber.asNumber(candyMachine?.state.price) || 0.05} SOL`;\n  };\n\n  useEffect(() => {\n    const mint = async () => {\n      await removeAccountChangeListener(\n        connection.connection,\n        webSocketSubscriptionId,\n      );\n      await onMint();\n\n      setClicked(false);\n      setVerified(false);\n    };\n    if (verified && clicked) {\n      mint();\n    }\n  }, [\n    verified,\n    clicked,\n    connection.connection,\n    onMint,\n    webSocketSubscriptionId,\n  ]);\n\n  const previousGatewayStatus = usePrevious(gatewayStatus);\n  useEffect(() => {\n    const fromStates = [\n      GatewayStatus.NOT_REQUESTED,\n      GatewayStatus.REFRESH_TOKEN_REQUIRED,\n    ];\n    const invalidToStates = [...fromStates, GatewayStatus.UNKNOWN];\n    if (\n      fromStates.find(state => previousGatewayStatus === state) &&\n      !invalidToStates.find(state => gatewayStatus === state)\n    ) {\n      setIsMinting(true);\n    }\n    console.log('change: ', gatewayStatus);\n  }, [setIsMinting, previousGatewayStatus, gatewayStatus]);\n\n  return (\n    <button\n    className='mint-button'\n      disabled={isMinting || !isActive}\n      onClick={async () => {\n        if (candyMachine?.state.isActive && candyMachine?.state.gatekeeper) {\n          const network =\n            candyMachine.state.gatekeeper.gatekeeperNetwork.toBase58();\n          if (network === 'ignREusXmGrscGNUesoU9mxfds9AiYTezUKex2PsZV6') {\n            if (gatewayStatus === GatewayStatus.ACTIVE) {\n              await onMint();\n            } else {\n              // setIsMinting(true);\n              await requestGatewayToken();\n              console.log('after: ', gatewayStatus);\n            }\n          } else if (\n            network === 'ttib7tuX8PTWPqFsmUFQTj78MbRhUmqxidJRDv4hRRE' ||\n            network === 'tibePmPaoTgrs929rWpu755EXaxC7M3SthVCf6GzjZt'\n          ) {\n            setClicked(true);\n            const gatewayToken = await findGatewayToken(\n              connection.connection,\n              wallet.publicKey!,\n              candyMachine.state.gatekeeper.gatekeeperNetwork,\n            );\n\n            if (gatewayToken?.isValid()) {\n              await onMint();\n            } else {\n              window.open(\n                `https://verify.encore.fans/?gkNetwork=${network}`,\n                '_blank',\n              );\n\n              const gatewayTokenAddress =\n                await getGatewayTokenAddressForOwnerAndGatekeeperNetwork(\n                  wallet.publicKey!,\n                  candyMachine.state.gatekeeper.gatekeeperNetwork,\n                );\n\n              setWebSocketSubscriptionId(\n                onGatewayTokenChange(\n                  connection.connection,\n                  gatewayTokenAddress,\n                  () => setVerified(true),\n                  'confirmed',\n                ),\n              );\n            }\n          } else {\n            setClicked(false);\n            throw new Error(`Unknown Gatekeeper Network: ${network}`);\n          }\n        } else {\n          await onMint();\n          setClicked(false);\n        }\n      }}\n    >\n      {getMintButtonContent()}\n    </button>\n  );\n};\n\nfunction usePrevious<T>(value: T): T | undefined {\n  const ref = useRef<T>();\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n","export default __webpack_public_path__ + \"static/media/box.c530f7bb.svg\";","import * as anchor from '@project-serum/anchor';\r\nimport {\r\n    awaitTransactionSignatureConfirmation,\r\n    CandyMachineAccount,\r\n    CANDY_MACHINE_PROGRAM,\r\n    getCandyMachineState,\r\n    mintOneToken,\r\n  } from '../scripts/candy-machine';\r\nimport { AlertState, getAtaForMint, toDate } from '../scripts/utils';\r\nimport { GatewayProvider } from '@civic/solana-gateway-react';\r\nimport { useEffect, useMemo, useState, useCallback } from 'react';\r\nimport { useWallet } from '@solana/wallet-adapter-react';\r\nimport { MintButton } from '../components/MintButton';\r\nimport { PublicKey, Transaction } from '@solana/web3.js';\r\nimport { sendTransaction } from '../scripts/connection';\r\nimport box from '../img/box.svg';\r\n\r\n\r\nexport interface MintCompProps {\r\n    candyMachineId?: anchor.web3.PublicKey;\r\n    connection: anchor.web3.Connection;\r\n    txTimeout: number;\r\n    rpcHost: string;\r\n}\r\n\r\nexport default function MintComponent(props:MintCompProps) {\r\n    const [alertState, setAlertState] = useState<AlertState>({\r\n        open: false,\r\n        message: '',\r\n        severity: undefined,\r\n      });\r\n    const [candyMachine, setCandyMachine] = useState<CandyMachineAccount>();\r\n    const [discountPrice, setDiscountPrice] = useState<anchor.BN>();\r\n    const [endDate, setEndDate] = useState<Date>();\r\n    const [isUserMinting, setIsUserMinting] = useState(false);\r\n    const [isActive, setIsActive] = useState(false);\r\n    const [itemsRemaining, setItemsRemaining] = useState<number>();\r\n    const [isWhitelistUser, setIsWhitelistUser] = useState(false);\r\n    const [isPresale, setIsPresale] = useState(false);\r\n\r\n    const rpcUrl = props.rpcHost;\r\n    const wallet = useWallet();\r\n  \r\n    const anchorWallet = useMemo(() => {\r\n      if (\r\n        !wallet ||\r\n        !wallet.publicKey ||\r\n        !wallet.signAllTransactions ||\r\n        !wallet.signTransaction\r\n      ) {\r\n        return;\r\n      }\r\n  \r\n      return {\r\n        publicKey: wallet.publicKey,\r\n        signAllTransactions: wallet.signAllTransactions,\r\n        signTransaction: wallet.signTransaction,\r\n      } as anchor.Wallet;\r\n    }, [wallet]);\r\n\r\n\r\n    const refreshCandyMachineState = useCallback(async () => {\r\n        if (!anchorWallet) {\r\n          return;\r\n        }\r\n    \r\n        if (props.candyMachineId) {\r\n          try {\r\n            const cndy = await getCandyMachineState(\r\n              anchorWallet,\r\n              props.candyMachineId,\r\n              props.connection,\r\n            );\r\n            let active =\r\n              cndy?.state.goLiveDate?.toNumber() < new Date().getTime() / 1000;\r\n            let presale = false;\r\n            // whitelist mint?\r\n            if (cndy?.state.whitelistMintSettings) {\r\n              // is it a presale mint?\r\n              if (\r\n                cndy.state.whitelistMintSettings.presale &&\r\n                (!cndy.state.goLiveDate ||\r\n                  cndy.state.goLiveDate.toNumber() > new Date().getTime() / 1000)\r\n              ) {\r\n                presale = true;\r\n              }\r\n              // is there a discount?\r\n              if (cndy.state.whitelistMintSettings.discountPrice) {\r\n                setDiscountPrice(cndy.state.whitelistMintSettings.discountPrice);\r\n              } else {\r\n                setDiscountPrice(undefined);\r\n                // when presale=false and discountPrice=null, mint is restricted\r\n                // to whitelist users only\r\n                if (!cndy.state.whitelistMintSettings.presale) {\r\n                  cndy.state.isWhitelistOnly = true;\r\n                }\r\n              }\r\n              // retrieves the whitelist token\r\n              const mint = new anchor.web3.PublicKey(\r\n                cndy.state.whitelistMintSettings.mint,\r\n              );\r\n              const token = (await getAtaForMint(mint, anchorWallet.publicKey))[0];\r\n    \r\n              try {\r\n                const balance = await props.connection.getTokenAccountBalance(\r\n                  token,\r\n                );\r\n                let valid = parseInt(balance.value.amount) > 0;\r\n                // only whitelist the user if the balance > 0\r\n                setIsWhitelistUser(valid);\r\n                active = (presale && valid) || active;\r\n              } catch (e) {\r\n                setIsWhitelistUser(false);\r\n                // no whitelist user, no mint\r\n                if (cndy.state.isWhitelistOnly) {\r\n                  active = false;\r\n                }\r\n                console.log('There was a problem fetching whitelist token balance');\r\n                console.log(e);\r\n              }\r\n            }\r\n            // datetime to stop the mint?\r\n            if (cndy?.state.endSettings?.endSettingType.date) {\r\n              setEndDate(toDate(cndy.state.endSettings.number));\r\n              if (\r\n                cndy.state.endSettings.number.toNumber() <\r\n                new Date().getTime() / 1000\r\n              ) {\r\n                active = false;\r\n              }\r\n            }\r\n            // amount to stop the mint?\r\n            if (cndy?.state.endSettings?.endSettingType.amount) {\r\n              let limit = Math.min(\r\n                cndy.state.endSettings.number.toNumber(),\r\n                cndy.state.itemsAvailable,\r\n              );\r\n              if (cndy.state.itemsRedeemed < limit) {\r\n                setItemsRemaining(limit - cndy.state.itemsRedeemed);\r\n              } else {\r\n                setItemsRemaining(0);\r\n                cndy.state.isSoldOut = true;\r\n              }\r\n            } else {\r\n              setItemsRemaining(cndy.state.itemsRemaining);\r\n            }\r\n    \r\n            if (cndy.state.isSoldOut) {\r\n              active = false;\r\n            }\r\n    \r\n            setIsActive((cndy.state.isActive = active));\r\n            setIsPresale((cndy.state.isPresale = presale));\r\n            setCandyMachine(cndy);\r\n          } catch (e) {\r\n            console.log('There was a problem fetching Candy Machine state');\r\n            console.log(e);\r\n          }\r\n        }\r\n      }, [anchorWallet, props.candyMachineId, props.connection]);\r\n    \r\n      const onMint = async (\r\n        beforeTransactions: Transaction[] = [],\r\n        afterTransactions: Transaction[] = [],\r\n      ) => {\r\n        try {\r\n          setIsUserMinting(true);\r\n          document.getElementById('#identity')?.click();\r\n          if (wallet.connected && candyMachine?.program && wallet.publicKey) {\r\n            let mintOne = await mintOneToken(\r\n              candyMachine,\r\n              wallet.publicKey,\r\n              beforeTransactions,\r\n              afterTransactions,\r\n            );\r\n    \r\n            const mintTxId = mintOne[0];\r\n    \r\n            let status: any = { err: true };\r\n            if (mintTxId) {\r\n              status = await awaitTransactionSignatureConfirmation(\r\n                mintTxId,\r\n                props.txTimeout,\r\n                props.connection,\r\n                true,\r\n              );\r\n            }\r\n    \r\n            if (status && !status.err) {\r\n              // manual update since the refresh might not detect\r\n              // the change immediately\r\n              let remaining = itemsRemaining! - 1;\r\n              setItemsRemaining(remaining);\r\n              setIsActive((candyMachine.state.isActive = remaining > 0));\r\n              candyMachine.state.isSoldOut = remaining === 0;\r\n              setAlertState({\r\n                open: true,\r\n                message: 'Congratulations! Mint succeeded!',\r\n                severity: 'success',\r\n              });\r\n            } else {\r\n              setAlertState({\r\n                open: true,\r\n                message: 'Mint failed! Please try again!',\r\n                severity: 'error',\r\n              });\r\n            }\r\n          }\r\n        } catch (error: any) {\r\n          let message = error.msg || 'Minting failed! Please try again!';\r\n          if (!error.msg) {\r\n            if (!error.message) {\r\n              message = 'Transaction Timeout! Please try again.';\r\n            } else if (error.message.indexOf('0x137')) {\r\n              console.log(error);\r\n              message = `SOLD OUT!`;\r\n            } else if (error.message.indexOf('0x135')) {\r\n              message = `Insufficient funds to mint. Please fund your wallet.`;\r\n            }\r\n          } else {\r\n            if (error.code === 311) {\r\n              console.log(error);\r\n              message = `SOLD OUT!`;\r\n              window.location.reload();\r\n            } else if (error.code === 312) {\r\n              message = `Minting period hasn't started yet.`;\r\n            }\r\n          }\r\n    \r\n          setAlertState({\r\n            open: true,\r\n            message,\r\n            severity: 'error',\r\n          });\r\n          // updates the candy machine state to reflect the lastest\r\n          // information on chain\r\n          refreshCandyMachineState();\r\n        } finally {\r\n          setIsUserMinting(false);\r\n        }\r\n      };\r\n      \r\n      useEffect(() => {\r\n        refreshCandyMachineState();\r\n      }, [\r\n        anchorWallet,\r\n        props.candyMachineId,\r\n        props.connection,\r\n        refreshCandyMachineState,\r\n      ]);\r\n\r\n\r\n    return (\r\n        <>\r\n                {(\r\n            <div className=\"mint-section\">\r\n                <h1 className=\"mint-header\">Sibe Protocol <br /> white list </h1>\r\n                <div className=\"mint-volume volume\">\r\n                    <h4 className=\"mint-volume-h4 volume-h4\">Volume</h4>\r\n                    <span className=\"mint-volume-data volume-data\">6666</span>\r\n                </div>\r\n                {itemsRemaining && <span className=\"volume\">Items remaining {itemsRemaining}</span>}\r\n                {candyMachine?.state.isActive &&\r\n                candyMachine?.state.gatekeeper &&\r\n                wallet.publicKey &&\r\n                wallet.signTransaction ? (\r\n                    <GatewayProvider\r\n                    wallet={{\r\n                        publicKey:\r\n                        wallet.publicKey ||\r\n                        new PublicKey(CANDY_MACHINE_PROGRAM),\r\n                        //@ts-ignore\r\n                        signTransaction: wallet.signTransaction,\r\n                    }}\r\n                    gatekeeperNetwork={\r\n                        candyMachine?.state?.gatekeeper?.gatekeeperNetwork\r\n                    }\r\n                    clusterUrl={rpcUrl}\r\n                    handleTransaction={async (transaction: Transaction) => {\r\n                        setIsUserMinting(true);\r\n                        const userMustSign = transaction.signatures.find(sig =>\r\n                        sig.publicKey.equals(wallet.publicKey!),\r\n                        );\r\n                        if (userMustSign) {\r\n                        setAlertState({\r\n                            open: true,\r\n                            message: 'Please sign one-time Civic Pass issuance',\r\n                            severity: 'info',\r\n                        });\r\n                        try {\r\n                            transaction = await wallet.signTransaction!(\r\n                            transaction,\r\n                            );\r\n                        } catch (e) {\r\n                            setAlertState({\r\n                            open: true,\r\n                            message: 'User cancelled signing',\r\n                            severity: 'error',\r\n                            });\r\n                            // setTimeout(() => window.location.reload(), 2000);\r\n                            setIsUserMinting(false);\r\n                            throw e;\r\n                        }\r\n                        } else {\r\n                        setAlertState({\r\n                            open: true,\r\n                            message: 'Refreshing Civic Pass',\r\n                            severity: 'info',\r\n                        });\r\n                        }\r\n                        try {\r\n                        await sendTransaction(\r\n                            props.connection,\r\n                            wallet,\r\n                            transaction,\r\n                            [],\r\n                            true,\r\n                            'confirmed',\r\n                        );\r\n                        setAlertState({\r\n                            open: true,\r\n                            message: 'Please sign minting',\r\n                            severity: 'info',\r\n                        });\r\n                        } catch (e) {\r\n                        setAlertState({\r\n                            open: true,\r\n                            message:\r\n                            'Solana dropped the transaction, please try again',\r\n                            severity: 'warning',\r\n                        });\r\n                        console.error(e);\r\n                        // setTimeout(() => window.location.reload(), 2000);\r\n                        setIsUserMinting(false);\r\n                        throw e;\r\n                        }\r\n                        await onMint();\r\n                    }}\r\n                    broadcastTransaction={false}\r\n                    options={{ autoShowModal: false }}\r\n                    >\r\n                    <MintButton\r\n                        candyMachine={candyMachine}\r\n                        isMinting={isUserMinting}\r\n                        setIsMinting={val => setIsUserMinting(val)}\r\n                        onMint={onMint}\r\n                        isActive={isActive || (isPresale && isWhitelistUser)}\r\n                    />\r\n                    </GatewayProvider>\r\n                ) : (\r\n                    <MintButton\r\n                    candyMachine={candyMachine}\r\n                    isMinting={isUserMinting}\r\n                    setIsMinting={val => setIsUserMinting(val)}\r\n                    onMint={onMint}\r\n                    isActive={isActive || (isPresale && isWhitelistUser)}\r\n                    />\r\n                )}\r\n                <img src={box} alt=\"box-img\" className=\"box-img\" />\r\n            </div>)}\r\n        </>\r\n\r\n    )\r\n}","import * as anchor from '@project-serum/anchor';\r\nimport Collections from '../routes/Collections';\r\nimport MintComponent from '../components/MintComponent';\r\n\r\nexport interface HomeProps {\r\n  candyMachineId?: anchor.web3.PublicKey;\r\n  connection: anchor.web3.Connection;\r\n  txTimeout: number;\r\n  rpcHost: string;\r\n}\r\n\r\nexport default function HomePage (props:HomeProps) {\r\n    return (\r\n        <div className=\"body\">\r\n          <div className=\"gradient\"></div>\r\n          <MintComponent candyMachineId={props.candyMachineId}\r\n                connection={props.connection}\r\n                txTimeout={props.txTimeout}\r\n                rpcHost={props.rpcHost}/>\r\n            <h1 className=\"collection-header\">SIBE NFT Collections</h1>\r\n            <Collections />\r\n        </div>\r\n    )\r\n}\r\n","import './styles/App.css';\n\nimport Header from './components/Header';\nimport Footer from './components/Footer';\nimport Overlay from './components/Overlay';\nimport { useOnClickOutside } from \"./hooks/useOnClickOutside\";\nimport * as anchor from '@project-serum/anchor';\nimport { useMemo, useState, useRef } from 'react';\nimport {\n  Routes,\n  Route,\n} from \"react-router-dom\";\nimport NftCard from './routes/NftCard';\nimport NFTMarketplace from './routes/NFTMarketplace';\nimport HomePage from './routes/HomePage';\nimport { clusterApiUrl } from '@solana/web3.js';\nimport { WalletAdapterNetwork } from '@solana/wallet-adapter-base';\nimport {\n  getPhantomWallet,\n  getSlopeWallet,\n  getSolflareWallet,\n  getSolletWallet,\n  getSolletExtensionWallet,\n} from '@solana/wallet-adapter-wallets';\nimport { WalletProvider, ConnectionProvider } from '@solana/wallet-adapter-react';\nimport { WalletModalProvider} from '@solana/wallet-adapter-react-ui';\nrequire('@solana/wallet-adapter-react-ui/styles.css');\n\n\nconst getCandyMachineId = (): anchor.web3.PublicKey | undefined => {\n  try {\n    const candyMachineId = new anchor.web3.PublicKey(\n      process.env.REACT_APP_CANDY_MACHINE_ID!,\n    );\n\n    return candyMachineId;\n  } catch (e) {\n    console.log('Failed to construct CandyMachineId', e);\n    return undefined;\n  }\n};\n\nconst candyMachineId = getCandyMachineId();\nconst network = process.env.REACT_APP_SOLANA_NETWORK as WalletAdapterNetwork;\nconst rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST!;\nconst connection = new anchor.web3.Connection(\n  rpcHost ? rpcHost : anchor.web3.clusterApiUrl('devnet'),\n);\n\nconst txTimeoutInMilliseconds = 30000;\n\nconst App = () => {\n  const [open, setOpen] = useState(false);\n  const node = useRef(); \n  useOnClickOutside(node, () => setOpen(false));\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n  const wallets = useMemo(\n    () => [\n      getPhantomWallet(),\n      getSolflareWallet(),\n      getSlopeWallet(),\n      getSolletWallet({ network }),\n      getSolletExtensionWallet({ network }),\n    ],\n    [],\n  );\n\n  return (\n      <ConnectionProvider endpoint={endpoint}>\n      <WalletProvider wallets={wallets} autoConnect>\n        <WalletModalProvider>\n            <Header open={open} setOpen={setOpen} />\n            { open ? <Overlay /> : \n            <Routes>\n              <Route path=\"/\" element={ <HomePage candyMachineId={candyMachineId}\n                connection={connection}\n                txTimeout={txTimeoutInMilliseconds}\n                rpcHost={rpcHost}/>} > \n              </Route>\n              <Route path=\"/:collectionId\" element={<NFTMarketplace />}> \n              </Route>\n              <Route path=\"/:collectionId/:itemId\" element={<NftCard />} />\n          </Routes> }\n            { !open && <Footer />}\n        </WalletModalProvider>\n      </WalletProvider>\n    </ConnectionProvider>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from \"react-dom\";\nimport {\n  BrowserRouter,\n} from \"react-router-dom\";\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\n\nimport './styles/index.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter>\n      <App></App>\n  </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\nreportWebVitals();\n","import * as anchor from '@project-serum/anchor';\nimport { TOKEN_PROGRAM_ID } from '@solana/spl-token';\nimport { SystemProgram } from '@solana/web3.js';\nimport {\n  LAMPORTS_PER_SOL,\n  SYSVAR_RENT_PUBKEY,\n  TransactionInstruction,\n} from '@solana/web3.js';\n\nexport interface AlertState {\n  open: boolean;\n  message: string;\n  severity: 'success' | 'info' | 'warning' | 'error' | undefined;\n}\n\nexport const toDate = (value?: anchor.BN) => {\n  if (!value) {\n    return;\n  }\n\n  return new Date(value.toNumber() * 1000);\n};\n\nconst numberFormater = new Intl.NumberFormat('en-US', {\n  style: 'decimal',\n  minimumFractionDigits: 2,\n  maximumFractionDigits: 2,\n});\n\nexport const formatNumber = {\n  format: (val?: number) => {\n    if (!val) {\n      return '--';\n    }\n\n    return numberFormater.format(val);\n  },\n  asNumber: (val?: anchor.BN) => {\n    if (!val) {\n      return undefined;\n    }\n\n    return val.toNumber() / LAMPORTS_PER_SOL;\n  },\n};\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID =\n  new anchor.web3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\n\nexport const CIVIC = new anchor.web3.PublicKey(\n  'gatem74V238djXdzWnJf94Wo1DcnuGkfijbf3AuBhfs',\n);\n\nexport const getAtaForMint = async (\n  mint: anchor.web3.PublicKey,\n  buyer: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [buyer.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  );\n};\n\nexport const getNetworkExpire = async (\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [gatekeeperNetwork.toBuffer(), Buffer.from('expire')],\n    CIVIC,\n  );\n};\n\nexport const getNetworkToken = async (\n  wallet: anchor.web3.PublicKey,\n  gatekeeperNetwork: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [\n      wallet.toBuffer(),\n      Buffer.from('gateway'),\n      Buffer.from([0, 0, 0, 0, 0, 0, 0, 0]),\n      gatekeeperNetwork.toBuffer(),\n    ],\n    CIVIC,\n  );\n};\n\nexport function createAssociatedTokenAccountInstruction(\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n}\n","import {\n  Keypair,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from '@solana/web3.js';\n\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const getErrorForTransaction = async (\n  connection: Connection,\n  txid: string,\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[][],\n  signers: Keypair[][],\n): Promise<(string | undefined)[]> {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids: string[] = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(\n          connection,\n          wallet,\n          instructions[0],\n          filteredSigners[0],\n          'single',\n        );\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const { txs } = await sendTransactions(\n          connection,\n          wallet,\n          instructions,\n          filteredSigners,\n          SequenceType.StopOnFailure,\n          'single',\n        );\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n      'Died on ',\n      stopPoint,\n      'retrying from instruction',\n      instructions[stopPoint],\n      'instructions length is',\n      instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\n\nexport const sendTransactions = async (\n  connection: Connection,\n  wallet: any,\n  instructionSet: TransactionInstruction[][],\n  signersSet: Keypair[][],\n  sequenceType: SequenceType = SequenceType.Parallel,\n  commitment: Commitment = 'singleGossip',\n  successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n  failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n  block?: BlockhashAndFeeCalculator,\n  beforeTransactions: Transaction[] = [],\n  afterTransactions: Transaction[] = [],\n): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = beforeTransactions;\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n  unsignedTxns.push(...afterTransactions);\n\n  const partiallySignedTransactions = unsignedTxns.filter(t =>\n    t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  const fullySignedTransactions = unsignedTxns.filter(\n    t => !t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  let signedTxns = await wallet.signAllTransactions(\n    partiallySignedTransactions,\n  );\n  signedTxns = fullySignedTransactions.concat(signedTxns);\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  console.log(\n    'Signed txns length',\n    signedTxns.length,\n    'vs handed in length',\n    instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise.then(({ txid, slot }) =>\n          successCallback(txid, i),\n        );\n        pendingTxns.push(signedTxnPromise);\n      } catch (e) {\n        console.log('Failed at txn index:', i);\n        console.log('Caught failure:', e);\n\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          return {\n            number: i,\n            txs: await Promise.all(pendingTxns),\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    const result = await Promise.all(pendingTxns);\n    return { number: signedTxns.length, txs: result };\n  }\n\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[] | Transaction,\n  signers: Keypair[],\n  awaitConfirmation = true,\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction: Transaction;\n  if (instructions instanceof Transaction) {\n    transaction = instructions;\n  } else {\n    transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = (\n      block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n\n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n      );\n    }\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      DEFAULT_TIMEOUT,\n      connection,\n      commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n  connection: Connection,\n  wallet: any,\n  instructions: TransactionInstruction[],\n  signers: Keypair[],\n  commitment: Commitment = 'singleGossip',\n  includesFeePayer: boolean = false,\n  block?: BlockhashAndFeeCalculator,\n  beforeSend?: () => void,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n    block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n      // fee payed by the wallet owner\n      wallet.publicKey,\n      ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nconst DEFAULT_TIMEOUT = 15000;\n\nexport async function sendSignedTransaction({\n  signedTransaction,\n  connection,\n  timeout = DEFAULT_TIMEOUT,\n}: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n    rawTransaction,\n    {\n      skipPreflight: true,\n    },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n      txid,\n      timeout,\n      connection,\n      'recent',\n      true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err: any) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n        await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n              'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n  connection: Connection,\n  transaction: Transaction,\n  commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n    // @ts-ignore\n    connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n  txid: TransactionSignature,\n  timeout: number,\n  connection: Connection,\n  commitment: Commitment = 'recent',\n  queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n        txid,\n        (result, context) => {\n          done = true;\n          status = {\n            err: result.err,\n            slot: context.slot,\n            confirmations: 0,\n          };\n          if (result.err) {\n            console.log('Rejected via websocket', result.err);\n            reject(status);\n          } else {\n            console.log('Resolved via websocket', result);\n            resolve(status);\n          }\n        },\n        commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n","import * as anchor from '@project-serum/anchor';\n\nimport { MintLayout, TOKEN_PROGRAM_ID, Token } from '@solana/spl-token';\nimport {\n  SystemProgram,\n  Transaction,\n  SYSVAR_SLOT_HASHES_PUBKEY,\n} from '@solana/web3.js';\nimport { sendTransactions, SequenceType } from './connection';\n\nimport {\n  CIVIC,\n  getAtaForMint,\n  getNetworkExpire,\n  getNetworkToken,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n} from './utils';\n\nexport const CANDY_MACHINE_PROGRAM = new anchor.web3.PublicKey(\n  'cndy3Z4yapfJBmL3ShUp5exZKqR3z33thTzeNMm2gRZ',\n);\n\nconst TOKEN_METADATA_PROGRAM_ID = new anchor.web3.PublicKey(\n  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',\n);\n\ninterface CandyMachineState {\n  authority: anchor.web3.PublicKey;\n  itemsAvailable: number;\n  itemsRedeemed: number;\n  itemsRemaining: number;\n  treasury: anchor.web3.PublicKey;\n  tokenMint: anchor.web3.PublicKey;\n  isSoldOut: boolean;\n  isActive: boolean;\n  isPresale: boolean;\n  isWhitelistOnly: boolean;\n  goLiveDate: anchor.BN;\n  price: anchor.BN;\n  gatekeeper: null | {\n    expireOnUse: boolean;\n    gatekeeperNetwork: anchor.web3.PublicKey;\n  };\n  endSettings: null | {\n    number: anchor.BN;\n    endSettingType: any;\n  };\n  whitelistMintSettings: null | {\n    mode: any;\n    mint: anchor.web3.PublicKey;\n    presale: boolean;\n    discountPrice: null | anchor.BN;\n  };\n  hiddenSettings: null | {\n    name: string;\n    uri: string;\n    hash: Uint8Array;\n  };\n  retainAuthority: boolean;\n}\n\nexport interface CandyMachineAccount {\n  id: anchor.web3.PublicKey;\n  program: anchor.Program;\n  state: CandyMachineState;\n}\n\nexport const awaitTransactionSignatureConfirmation = async (\n  txid: anchor.web3.TransactionSignature,\n  timeout: number,\n  connection: anchor.web3.Connection,\n  queryStatus = false,\n): Promise<anchor.web3.SignatureStatus | null | void> => {\n  let done = false;\n  let status: anchor.web3.SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId]) {\n    connection.removeSignatureListener(subId);\n  }\n  done = true;\n  console.log('Returning status', status);\n  return status;\n};\n\nconst createAssociatedTokenAccountInstruction = (\n  associatedTokenAddress: anchor.web3.PublicKey,\n  payer: anchor.web3.PublicKey,\n  walletAddress: anchor.web3.PublicKey,\n  splTokenMintAddress: anchor.web3.PublicKey,\n) => {\n  const keys = [\n    { pubkey: payer, isSigner: true, isWritable: true },\n    { pubkey: associatedTokenAddress, isSigner: false, isWritable: true },\n    { pubkey: walletAddress, isSigner: false, isWritable: false },\n    { pubkey: splTokenMintAddress, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },\n    {\n      pubkey: anchor.web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new anchor.web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n};\n\nexport const getCandyMachineState = async (\n  anchorWallet: anchor.Wallet,\n  candyMachineId: anchor.web3.PublicKey,\n  connection: anchor.web3.Connection,\n): Promise<CandyMachineAccount> => {\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'processed',\n  });\n\n  const idl = await anchor.Program.fetchIdl(CANDY_MACHINE_PROGRAM, provider);\n\n  const program = new anchor.Program(idl!, CANDY_MACHINE_PROGRAM, provider);\n\n  const state: any = await program.account.candyMachine.fetch(candyMachineId);\n  const itemsAvailable = state.data.itemsAvailable.toNumber();\n  const itemsRedeemed = state.itemsRedeemed.toNumber();\n  const itemsRemaining = itemsAvailable - itemsRedeemed;\n\n  return {\n    id: candyMachineId,\n    program,\n    state: {\n      authority: state.authority,\n      itemsAvailable,\n      itemsRedeemed,\n      itemsRemaining,\n      isSoldOut: itemsRemaining === 0,\n      isActive: false,\n      isPresale: false,\n      isWhitelistOnly: false,\n      goLiveDate: state.data.goLiveDate,\n      treasury: state.wallet,\n      tokenMint: state.tokenMint,\n      gatekeeper: state.data.gatekeeper,\n      endSettings: state.data.endSettings,\n      whitelistMintSettings: state.data.whitelistMintSettings,\n      hiddenSettings: state.data.hiddenSettings,\n      price: state.data.price,\n      retainAuthority: state.data.retainAuthority,\n    },\n  };\n};\n\nconst getMasterEdition = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('edition'),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nconst getMetadata = async (\n  mint: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const getCandyMachineCreator = async (\n  candyMachine: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from('candy_machine'), candyMachine.toBuffer()],\n    CANDY_MACHINE_PROGRAM,\n  );\n};\n\nexport const getCollectionPDA = async (\n  candyMachineAddress: anchor.web3.PublicKey,\n): Promise<[anchor.web3.PublicKey, number]> => {\n  return await anchor.web3.PublicKey.findProgramAddress(\n    [Buffer.from('collection'), candyMachineAddress.toBuffer()],\n    CANDY_MACHINE_PROGRAM,\n  );\n};\n\nexport interface CollectionData {\n  mint: anchor.web3.PublicKey;\n  candyMachine: anchor.web3.PublicKey;\n}\n\nexport const getCollectionAuthorityRecordPDA = async (\n  mint: anchor.web3.PublicKey,\n  newAuthority: anchor.web3.PublicKey,\n): Promise<anchor.web3.PublicKey> => {\n  return (\n    await anchor.web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from('metadata'),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from('collection_authority'),\n        newAuthority.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID,\n    )\n  )[0];\n};\n\nexport const mintOneToken = async (\n  candyMachine: CandyMachineAccount,\n  payer: anchor.web3.PublicKey,\n  beforeTransactions: Transaction[] = [],\n  afterTransactions: Transaction[] = [],\n): Promise<(string | undefined)[]> => {\n  const mint = anchor.web3.Keypair.generate();\n\n  const userTokenAccountAddress = (\n    await getAtaForMint(mint.publicKey, payer)\n  )[0];\n\n  const userPayingAccountAddress = candyMachine.state.tokenMint\n    ? (await getAtaForMint(candyMachine.state.tokenMint, payer))[0]\n    : payer;\n\n  const candyMachineAddress = candyMachine.id;\n\n  const remainingAccounts = [];\n  const signers: anchor.web3.Keypair[] = [mint];\n  const cleanupInstructions = [];\n  const instructions = [\n    anchor.web3.SystemProgram.createAccount({\n      fromPubkey: payer,\n      newAccountPubkey: mint.publicKey,\n      space: MintLayout.span,\n      lamports:\n        await candyMachine.program.provider.connection.getMinimumBalanceForRentExemption(\n          MintLayout.span,\n        ),\n      programId: TOKEN_PROGRAM_ID,\n    }),\n    Token.createInitMintInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      0,\n      payer,\n      payer,\n    ),\n    createAssociatedTokenAccountInstruction(\n      userTokenAccountAddress,\n      payer,\n      payer,\n      mint.publicKey,\n    ),\n    Token.createMintToInstruction(\n      TOKEN_PROGRAM_ID,\n      mint.publicKey,\n      userTokenAccountAddress,\n      payer,\n      [],\n      1,\n    ),\n  ];\n\n  if (candyMachine.state.gatekeeper) {\n    remainingAccounts.push({\n      pubkey: (\n        await getNetworkToken(\n          payer,\n          candyMachine.state.gatekeeper.gatekeeperNetwork,\n        )\n      )[0],\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (candyMachine.state.gatekeeper.expireOnUse) {\n      remainingAccounts.push({\n        pubkey: CIVIC,\n        isWritable: false,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: (\n          await getNetworkExpire(\n            candyMachine.state.gatekeeper.gatekeeperNetwork,\n          )\n        )[0],\n        isWritable: false,\n        isSigner: false,\n      });\n    }\n  }\n  if (candyMachine.state.whitelistMintSettings) {\n    const mint = new anchor.web3.PublicKey(\n      candyMachine.state.whitelistMintSettings.mint,\n    );\n\n    const whitelistToken = (await getAtaForMint(mint, payer))[0];\n    remainingAccounts.push({\n      pubkey: whitelistToken,\n      isWritable: true,\n      isSigner: false,\n    });\n\n    if (candyMachine.state.whitelistMintSettings.mode.burnEveryTime) {\n      const whitelistBurnAuthority = anchor.web3.Keypair.generate();\n\n      remainingAccounts.push({\n        pubkey: mint,\n        isWritable: true,\n        isSigner: false,\n      });\n      remainingAccounts.push({\n        pubkey: whitelistBurnAuthority.publicKey,\n        isWritable: false,\n        isSigner: true,\n      });\n      signers.push(whitelistBurnAuthority);\n      const exists =\n        await candyMachine.program.provider.connection.getAccountInfo(\n          whitelistToken,\n        );\n      if (exists) {\n        instructions.push(\n          Token.createApproveInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            whitelistBurnAuthority.publicKey,\n            payer,\n            [],\n            1,\n          ),\n        );\n        cleanupInstructions.push(\n          Token.createRevokeInstruction(\n            TOKEN_PROGRAM_ID,\n            whitelistToken,\n            payer,\n            [],\n          ),\n        );\n      }\n    }\n  }\n\n  if (candyMachine.state.tokenMint) {\n    const transferAuthority = anchor.web3.Keypair.generate();\n\n    signers.push(transferAuthority);\n    remainingAccounts.push({\n      pubkey: userPayingAccountAddress,\n      isWritable: true,\n      isSigner: false,\n    });\n    remainingAccounts.push({\n      pubkey: transferAuthority.publicKey,\n      isWritable: false,\n      isSigner: true,\n    });\n\n    instructions.push(\n      Token.createApproveInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        transferAuthority.publicKey,\n        payer,\n        [],\n        candyMachine.state.price.toNumber(),\n      ),\n    );\n    cleanupInstructions.push(\n      Token.createRevokeInstruction(\n        TOKEN_PROGRAM_ID,\n        userPayingAccountAddress,\n        payer,\n        [],\n      ),\n    );\n  }\n  const metadataAddress = await getMetadata(mint.publicKey);\n  const masterEdition = await getMasterEdition(mint.publicKey);\n\n  const [candyMachineCreator, creatorBump] = await getCandyMachineCreator(\n    candyMachineAddress,\n  );\n\n  console.log(remainingAccounts.map(rm => rm.pubkey.toBase58()));\n  instructions.push(\n    await candyMachine.program.instruction.mintNft(creatorBump, {\n      accounts: {\n        candyMachine: candyMachineAddress,\n        candyMachineCreator,\n        payer: payer,\n        wallet: candyMachine.state.treasury,\n        mint: mint.publicKey,\n        metadata: metadataAddress,\n        masterEdition,\n        mintAuthority: payer,\n        updateAuthority: payer,\n        tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n        tokenProgram: TOKEN_PROGRAM_ID,\n        systemProgram: SystemProgram.programId,\n        rent: anchor.web3.SYSVAR_RENT_PUBKEY,\n        clock: anchor.web3.SYSVAR_CLOCK_PUBKEY,\n        recentBlockhashes: SYSVAR_SLOT_HASHES_PUBKEY,\n        instructionSysvarAccount: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n      },\n      remainingAccounts:\n        remainingAccounts.length > 0 ? remainingAccounts : undefined,\n    }),\n  );\n\n  const [collectionPDA] = await getCollectionPDA(candyMachineAddress);\n  const collectionPDAAccount =\n    await candyMachine.program.provider.connection.getAccountInfo(\n      collectionPDA,\n    );\n\n  if (collectionPDAAccount && candyMachine.state.retainAuthority) {\n    try {\n      const collectionData =\n        (await candyMachine.program.account.collectionPda.fetch(\n          collectionPDA,\n        )) as CollectionData;\n      console.log(collectionData);\n      const collectionMint = collectionData.mint;\n      const collectionAuthorityRecord = await getCollectionAuthorityRecordPDA(\n        collectionMint,\n        collectionPDA,\n      );\n      console.log(collectionMint);\n      if (collectionMint) {\n        const collectionMetadata = await getMetadata(collectionMint);\n        const collectionMasterEdition = await getMasterEdition(collectionMint);\n        console.log('Collection PDA: ', collectionPDA.toBase58());\n        console.log('Authority: ', candyMachine.state.authority.toBase58());\n        instructions.push(\n          await candyMachine.program.instruction.setCollectionDuringMint({\n            accounts: {\n              candyMachine: candyMachineAddress,\n              metadata: metadataAddress,\n              payer: payer,\n              collectionPda: collectionPDA,\n              tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,\n              instructions: anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,\n              collectionMint,\n              collectionMetadata,\n              collectionMasterEdition,\n              authority: candyMachine.state.authority,\n              collectionAuthorityRecord,\n            },\n          }),\n        );\n      }\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  const instructionsMatrix: anchor.web3.TransactionInstruction[][] = [];\n  const signersMatrix: anchor.web3.Keypair[][] = [];\n\n  const state = candyMachine.state;\n  const txnEstimate =\n    892 +\n    (collectionPDAAccount && state.retainAuthority ? 182 : 0) +\n    (state.tokenMint ? 177 : 0) +\n    (state.whitelistMintSettings ? 33 : 0) +\n    (state.whitelistMintSettings?.mode?.burnEveryTime ? 145 : 0) +\n    (state.gatekeeper ? 33 : 0) +\n    (state.gatekeeper?.expireOnUse ? 66 : 0);\n\n  const INIT_INSTRUCTIONS_LENGTH = 4;\n  const INIT_SIGNERS_LENGTH = 1;\n\n  console.log('Transaction estimate: ', txnEstimate);\n  if (txnEstimate > 1230) {\n    const initInstructions = instructions.splice(0, INIT_INSTRUCTIONS_LENGTH);\n    console.log(initInstructions);\n    instructionsMatrix.push(initInstructions);\n    const initSigners = signers.splice(0, INIT_SIGNERS_LENGTH);\n    signersMatrix.push(initSigners);\n  }\n\n  instructionsMatrix.push(instructions);\n  signersMatrix.push(signers);\n\n  if (cleanupInstructions.length > 0) {\n    instructionsMatrix.push(cleanupInstructions);\n    signersMatrix.push([]);\n  }\n\n  try {\n    return (\n      await sendTransactions(\n        candyMachine.program.provider.connection,\n        candyMachine.program.provider.wallet,\n        instructionsMatrix,\n        signersMatrix,\n        SequenceType.StopOnFailure,\n        'singleGossip',\n        () => {},\n        () => false,\n        undefined,\n        beforeTransactions,\n        afterTransactions,\n      )\n    ).txs.map(t => t.txid);\n  } catch (e) {\n    console.log(e);\n  }\n\n  return [];\n};\n\nexport const shortenAddress = (address: string, chars = 4): string => {\n  return `${address.slice(0, chars)}...${address.slice(-chars)}`;\n};\n\nconst sleep = (ms: number): Promise<void> => {\n  return new Promise(resolve => setTimeout(resolve, ms));\n};\n"],"sourceRoot":""}